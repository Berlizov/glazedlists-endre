<html>
<head><title>Glazed Lists Tutorial Part 8 - Performance Tuning</title>
</head>
<body>
<div class="app">

<h3>Glazed Lists Tutorial</h3>
<h1>Part 8 - Performance Tuning</h1>

<p>Once your is application up and running you might want to make it faster. Here are
some simple techniques to squeeze more performance out of Glazed Lists.

<a name="filtering"></a><h3>Faster Filtering</h3>
<p>For filtering you have implemented <code>Filterable</code> in your
list objects or <code>Filterator</code> as a utility class. Each of these
must implement a <code>getFilterStrings()</code> method that returns
<code>String[]</code>. Rather than constructing a new <code>String[]</code> every
time <code>toFilterStrings()</code> is called, add a member <code>String[]</code> called
<code>filterStrings</code> and return that instead. This will save on memory
allocation and garbage collection to speed up your filtering.

<p><table cellpadding="5" cellspacing="0" width="100%" border="1" bgcolor="#EEEEEE"><tr><td><pre><code>class ProgrammingLanguage implements Filterable {
    private String name;
    private String year;
    private String description;
    <font color="#FF3333">private String[] filterStrings = new String[3];</font>
    
    ...

    public String[] getFilterStrings() {
        <font color="#666666">// return new String[] { name, year, description };</code>

        <font color="#FF3333">filterStrings[0] = name;</font>
        <font color="#FF3333">filterStrings[1] = year;</font>
        <font color="#FF3333">filterStrings[2] = description;</font>
        <font color="#FF3333">return filterStrings;</font>
    }

...</code></pre></td></tr></table>

<p>Each <code>CaseInsensitiveFilterList</code> uses only one of its <code>Filterator</code>'s
<code>getFilterStrings()</code> return values at a time. This means it is safe to reuse
a single <code>String[]</code> for each <code>Filterator</code> as long as it is being
used by only one <code>CaseInsensitiveFilterList</code>.

<a name="trash"></a><h3>Trash Events After Reading Them</h3>
<p> If you have written a class that implements <code>ListChangeListener</code>, you
should be aware of a potential memory leak that occurs when failing to mark
<code>ListChangeEvent</code>s as read.

<p>When a list is changed Glazed Lists provides fine-grained access to exactly
where the change was. For example, if a filter removes a subset of the elements
in a list the <code>ListChangeEvent</code> will contain each of the indicies for the removed
elements. Fine-grained changes allows Glazed Lists to perform minimal updates for
the best performance.

<p>The tradeoff of using fine-grained changes is that there is memory overhead
for each change object. This change objects are shared among a set of <code>ListChangeEvent</code>s,
and managed by a helper class, <code>ListChangeSequence</code>.

<p>When a <code>ListChangeListener</code> processes a <code>ListChangeEvent</code>,
it must notify the <code>ListChangeEvent</code> that it has completed viewing the
current change so that they can be garbage-collected. There are two ways to notify
the <code>ListChangeEvent</code> that the changes have been processed:

<li>The <code>ListChangeEvent</code> can be notified <strong>implicitly</strong>, by
iterating through the changes in the event in a series of calls to <code>next()</code>.
<li>The <code>ListChangeEvent</code> can be notified <strong>explicitly</strong>, by
calling the method <code>clearEventQueue()</code>.

<p>Only after all listeners for a particular change have read it will the change be
garbage collected. If a <code>ListChangeListener</code> never iterates or clears its
change events, change ojbects will be allocated but never garbage collected so the
application will have a memory leak.

<a name="rowheight"></a><h3>Use a fixed row height</h3>
<p>By using custom renderers such as <code>StyledDocumentRenderer</code> with variable
row heights, the <code>JTable</code> does a lot of work to keep track of the height for
each row. When Glazed Lists has a sequence of change events it can take a noticeable
amount of time for the JTable to update its row heights.

<p>The solution of course is to use <strong>fixed</strong> row heights. To use fixed
row heights with <code>StyledDocumentRenderer</code>, specify <code>false</code> as the
argument to <code>super()</code> in the constructor and manually set the table's fixed row
height elsewhere using <code>JTable.setRowHeight(int)</code>. This prevents the renderer
from individually adjusting each row's height and will avoid that performance problem.

<p>If you absolutely must use variable row heights, be sure to call
<code>ListTable.setRepaintAllThreshhold(100)</code> which can group your change blocks
to work around the <code>JTable</code>'s slow row height handling. Note that although
behaviour is much faster, it causes the <strong>selection and scrolling to be lost<strong>
when many changes occur simultaneously such as when your list is filtered.

<br><br><p><table cellpadding="0" cellspacing="0" width="100%" border="0"><tr>
<th align="left" width="30%"><a href="../part7/index.html">&lt;&lt; Part 7 - JComboBox</a></th> 
<th align="center" width="40%"><a href="../index.html">Tutorial Home</a></th>
<th align="right" width="30%"><a href="../part9/index.html">Part 9 - JList &gt;&gt;</a></th>
</tr></table><br><br><br>

</div>
</body>
</html>
