

<issuezilla exporter="guest" charset="UTF-8" version="2.11" urlbase="https://glazedlists.dev.java.net/issues/" maintainer="owner@glazedlists.dev.java.net" project_domain="dev.java.net" project_name="glazedlists" project_id="1073" dtd_version="Revision: 1.2">
<issue status_code="200" status_message="OK">
  <issue_id>1</issue_id>
  <issue_status>CLOSED</issue_status>
  <priority>P3</priority>
  <resolution>FIXED</resolution>
  <component>glazedlists</component>
  <version>current</version>
  <rep_platform>All</rep_platform>
  <assigned_to>jessewilson</assigned_to>
  <delta_ts>20040521142009</delta_ts>
  <subcomponent>www</subcomponent>
  <reporter>jessewilson</reporter>
  <target_milestone>milestone 1</target_milestone>
  <issue_type>TASK</issue_type>
  <creation_ts>2003-12-02 22:09:52</creation_ts>
  <qa_contact>issues@glazedlists</qa_contact>
  <status_whiteboard></status_whiteboard>
  <votes></votes>
  <op_sys>All</op_sys>
  <short_desc>Improve filter performance upon list change</short_desc>
  <keywords></keywords>
  <long_desc>
   <who>jessewilson</who>
   <issue_when>2003-12-02 22:09:52</issue_when>
   <thetext>The current implementation of filtering uses a N*N*M algorithm to re-filter when the list 
changes, for M changes on a list of size N.

It is necessary to improve this runtime by using more appropriate data structures inside 
the AbstractFilterList.</thetext>
  </long_desc>
  <long_desc>
   <who>jessewilson</who>
   <issue_when>2004-04-06 09:45:50</issue_when>
   <thetext>Created an attachment (id=1)
screenshot from profiler
</thetext>
  </long_desc>
  <long_desc>
   <who>jessewilson</who>
   <issue_when>2004-04-06 09:47:00</issue_when>
   <thetext>In creating a test case I found that the filter performance can be really bad in certain situations.

I think this case can be justification for updating the AbstractFilterList to use a SparseList instead of the 
current arraylist hack.</thetext>
  </long_desc>
  <long_desc>
   <who>jessewilson</who>
   <issue_when>2004-04-08 08:50:13</issue_when>
   <thetext>I have changed the AbstractFilterList to use SparseList instead of the hack array data structure. The 
results are impressive in some cases only and not noticable in other cases. This change will cause 
change events to be orders of magnitude faster, while get() events will be slightly slower.

Here is the results in elapsed time from two tests I ran, before and after the fix:
CaseInsensitiveFilterListTest
before: 3.9s
after: 2.8s

MultipleListenersTest
before: 162.9s
after: 19.2s</thetext>
  </long_desc>
  <long_desc>
   <who>jessewilson</who>
   <issue_when>2004-05-21 14:20:09</issue_when>
   <thetext>This bug has been fixed for two weeks with no problems. I am marking it closed.</thetext>
  </long_desc>
  <attachment encoding="Base64">
    <mimetype>image/png</mimetype>
    <attachid>1</attachid>
    <date>2004-04-06 09:45:50</date>
    <desc>screenshot from profiler</desc>
    <ispatch></ispatch>
    <filename>hprof.png</filename>
    <submitter_id>3</submitter_id>
    <submitting_username>jessewilson</submitting_username>
    <data></data>
  <attachment_iz_url>https://glazedlists.dev.java.net/nonav/issues/showattachment.cgi/1/hprof.png</attachment_iz_url>
  </attachment>
  <activity>
    <user>jessewilson</user>
    <when>2004-04-06 09:45:50</when>
    <field_name>attachments.thedata</field_name>
    <field_desc>Attachment Data</field_desc>
    <oldvalue></oldvalue>
    <newvalue>Created an attachment (id=1)
screenshot from profiler
</newvalue>
  </activity>
  <activity>
    <user>jessewilson</user>
    <when>2004-04-08 08:50:13</when>
    <field_name>issue_status</field_name>
    <field_desc>Status</field_desc>
    <oldvalue>NEW</oldvalue>
    <newvalue>RESOLVED</newvalue>
  </activity>
  <activity>
    <user>jessewilson</user>
    <when>2004-04-08 08:50:13</when>
    <field_name>resolution</field_name>
    <field_desc>Resolution</field_desc>
    <oldvalue></oldvalue>
    <newvalue>FIXED</newvalue>
  </activity>
  <activity>
    <user>jessewilson</user>
    <when>2004-05-21 14:20:09</when>
    <field_name>issue_status</field_name>
    <field_desc>Status</field_desc>
    <oldvalue>RESOLVED</oldvalue>
    <newvalue>CLOSED</newvalue>
  </activity>
</issue>
<issue status_code="200" status_message="OK">
  <issue_id>2</issue_id>
  <issue_status>CLOSED</issue_status>
  <priority>P2</priority>
  <resolution>FIXED</resolution>
  <component>glazedlists</component>
  <version>current</version>
  <rep_platform>All</rep_platform>
  <assigned_to>jessewilson</assigned_to>
  <delta_ts>20040130155512</delta_ts>
  <subcomponent>www</subcomponent>
  <reporter>jessewilson</reporter>
  <target_milestone>milestone 1</target_milestone>
  <issue_type>DEFECT</issue_type>
  <creation_ts>2003-12-02 22:11:34</creation_ts>
  <qa_contact>issues@glazedlists</qa_contact>
  <status_whiteboard></status_whiteboard>
  <votes></votes>
  <op_sys>All</op_sys>
  <short_desc>Filter regex fails with special characters</short_desc>
  <keywords></keywords>
  <long_desc>
   <who>jessewilson</who>
   <issue_when>2003-12-02 22:11:34</issue_when>
   <thetext>The current filter code for CaseInsensitiveFilterList fails to work when the filter text 
contains regular-expression characters such as dot.

Fix this to handle special characters as they should be.</thetext>
  </long_desc>
  <long_desc>
   <who>jessewilson</who>
   <issue_when>2003-12-27 14:40:16</issue_when>
   <thetext>Fixed in CVS. Added a method getMatcher() that constructs a matcher using the source 
string</thetext>
  </long_desc>
  <long_desc>
   <who>jessewilson</who>
   <issue_when>2004-01-30 15:55:12</issue_when>
   <thetext>This bug has been fixed for two weeks with no problems. I am marking it closed.</thetext>
  </long_desc>
  <activity>
    <user>jessewilson</user>
    <when>2003-12-27 14:40:16</when>
    <field_name>issue_status</field_name>
    <field_desc>Status</field_desc>
    <oldvalue>NEW</oldvalue>
    <newvalue>RESOLVED</newvalue>
  </activity>
  <activity>
    <user>jessewilson</user>
    <when>2003-12-27 14:40:16</when>
    <field_name>resolution</field_name>
    <field_desc>Resolution</field_desc>
    <oldvalue></oldvalue>
    <newvalue>FIXED</newvalue>
  </activity>
  <activity>
    <user>jessewilson</user>
    <when>2004-01-30 15:55:12</when>
    <field_name>issue_status</field_name>
    <field_desc>Status</field_desc>
    <oldvalue>RESOLVED</oldvalue>
    <newvalue>CLOSED</newvalue>
  </activity>
</issue>
<issue status_code="200" status_message="OK">
  <issue_id>3</issue_id>
  <issue_status>CLOSED</issue_status>
  <priority>P3</priority>
  <resolution>FIXED</resolution>
  <component>glazedlists</component>
  <version>current</version>
  <rep_platform>All</rep_platform>
  <assigned_to>issues@glazedlists</assigned_to>
  <delta_ts>20040130155416</delta_ts>
  <subcomponent>www</subcomponent>
  <reporter>ildella</reporter>
  <target_milestone>milestone 1</target_milestone>
  <issue_type>DEFECT</issue_type>
  <creation_ts>2004-01-07 17:36:37</creation_ts>
  <qa_contact>issues@glazedlists</qa_contact>
  <status_whiteboard></status_whiteboard>
  <votes></votes>
  <op_sys>All</op_sys>
  <short_desc>EventListIterator problem with remove() method</short_desc>
  <keywords></keywords>
  <long_desc>
   <who>ildella</who>
   <issue_when>2004-01-07 17:36:37</issue_when>
   <thetext>This code doesn't seem to work properly: 
(variable "songs" is a BasicEventList)

	public int cleanFromMissingFiles() {
		Iterator it = songs.iterator();
		while (it.hasNext()) {
			MP3Song song = (MP3Song) it.next();
			File f = new File(song.getPath());
			if (!f.exists())
				it.remove();	
		}
	}

if there are 2 items to remove, after removing the first, the iterator return
false at the next call to hasNext()
if, for example, there are 8 items to remove, the hasNext() return false after
the 4th remove() calls. 
And so on...

the rest of the code is right, in fact, with this code:

	public int cleanFromMissingFiles() {
		List list = new LinkedList();
		list.addAll(songs);
		Iterator it = list.iterator();
		while (it.hasNext()) {
			MP3Song song = (MP3Song) it.next();
			File f = new File(song.getPath());
			if (!f.exists())
				it.remove();
		}
		songs.clear();
		songs.addAll(list);
	}

everything is all right.

hope this can help.
bye.</thetext>
  </long_desc>
  <long_desc>
   <who>jessewilson</who>
   <issue_when>2004-01-09 13:03:16</issue_when>
   <thetext>This was a defect in my iterator code.

The iterator contains two indexes - the index of the last item viewed and the index of the 
next item to view. When a remove occurred, only the last item viewed index was updated. 

The next item to view index needed to be shifted down by one whenever a remove would 
cause the list's indicies to shift down by one.</thetext>
  </long_desc>
  <long_desc>
   <who>jessewilson</who>
   <issue_when>2004-01-30 15:54:16</issue_when>
   <thetext>This bug has been fixed for two weeks with no problems. I am marking it closed.</thetext>
  </long_desc>
  <activity>
    <user>jessewilson</user>
    <when>2004-01-09 13:03:16</when>
    <field_name>issue_status</field_name>
    <field_desc>Status</field_desc>
    <oldvalue>NEW</oldvalue>
    <newvalue>RESOLVED</newvalue>
  </activity>
  <activity>
    <user>jessewilson</user>
    <when>2004-01-09 13:03:16</when>
    <field_name>resolution</field_name>
    <field_desc>Resolution</field_desc>
    <oldvalue></oldvalue>
    <newvalue>FIXED</newvalue>
  </activity>
  <activity>
    <user>jessewilson</user>
    <when>2004-01-30 15:54:16</when>
    <field_name>issue_status</field_name>
    <field_desc>Status</field_desc>
    <oldvalue>RESOLVED</oldvalue>
    <newvalue>CLOSED</newvalue>
  </activity>
</issue>
<issue status_code="200" status_message="OK">
  <issue_id>4</issue_id>
  <issue_status>CLOSED</issue_status>
  <priority>P3</priority>
  <resolution>FIXED</resolution>
  <component>glazedlists</component>
  <version>current</version>
  <rep_platform>All</rep_platform>
  <assigned_to>jessewilson</assigned_to>
  <delta_ts>20040211073459</delta_ts>
  <subcomponent>www</subcomponent>
  <reporter>ildella</reporter>
  <target_milestone>milestone 1</target_milestone>
  <issue_type>DEFECT</issue_type>
  <creation_ts>2004-01-14 20:06:46</creation_ts>
  <qa_contact>issues@glazedlists</qa_contact>
  <status_whiteboard></status_whiteboard>
  <votes></votes>
  <op_sys>All</op_sys>
  <short_desc>Error in setting header value in TableComparatorSelector</short_desc>
  <keywords></keywords>
  <long_desc>
   <who>ildella</who>
   <issue_when>2004-01-14 20:06:46</issue_when>
   <thetext>Maybe there is a problem in TableComparatorSelector.

I set tableHeader.setReorderingAllowed(true) on a table which has its own
TableComparatorSelector. 
I move a column. After moving, the index of the column is changed, but the
modelIndex remains unchanged. 
This is wel handled in method mouseClicked with trhis code 

        int viewColumn = columnModel.getColumnIndexAtX(e.getX()); 
        int column = table.convertColumnIndexToModel(viewColumn); 

the last method, which rewrite the table header of all the columns, has the
following code:

        // and set the name of the table header to the current comparator
        for(int c = 0; c &lt; table.getColumnCount(); c++) {
            if(c == column) {                                                       
              table.getColumnModel().getColumn(column).setHeaderValue(sortedHeader);
            } else {
                String header = listTable.getTableFormat().getFieldName(c);
                table.getColumnModel().getColumn(c).setHeaderValue(header);
            }
        }

this method doesn't seem to handle difference between column index and model index.
In my app, when I move a column and then click on the header for resorting the
table, all the header value happen to move from their position. And this seems
to be caused by that portion of code wich, I guess, has to use the view index
and not the model index of the column. 

If I am right, that code has to handle difference between index and model index.
If I am wrong, there are different way to handle this thing?</thetext>
  </long_desc>
  <long_desc>
   <who>jessewilson</who>
   <issue_when>2004-01-15 14:49:48</issue_when>
   <thetext>The problem looks legit. In most of my use of ListTable I use only a single column so 
multiple columns is not well exercised!

I'll try to reproduce the problem and look into a fix.</thetext>
  </long_desc>
  <long_desc>
   <who>jessewilson</who>
   <issue_when>2004-01-22 14:51:50</issue_when>
   <thetext>I've fixed the bug and done preliminary testing to verify that the fix worked.</thetext>
  </long_desc>
  <long_desc>
   <who>jessewilson</who>
   <issue_when>2004-02-11 07:34:59</issue_when>
   <thetext>This bug has been fixed for two weeks with no problems. I am marking it closed.</thetext>
  </long_desc>
  <activity>
    <user>jessewilson</user>
    <when>2004-01-15 14:49:48</when>
    <field_name>assigned_to</field_name>
    <field_desc>Assigned To</field_desc>
    <oldvalue>issues@glazedlists</oldvalue>
    <newvalue>jessewilson</newvalue>
  </activity>
  <activity>
    <user>jessewilson</user>
    <when>2004-01-22 14:51:50</when>
    <field_name>issue_status</field_name>
    <field_desc>Status</field_desc>
    <oldvalue>NEW</oldvalue>
    <newvalue>RESOLVED</newvalue>
  </activity>
  <activity>
    <user>jessewilson</user>
    <when>2004-01-22 14:51:50</when>
    <field_name>resolution</field_name>
    <field_desc>Resolution</field_desc>
    <oldvalue></oldvalue>
    <newvalue>FIXED</newvalue>
  </activity>
  <activity>
    <user>jessewilson</user>
    <when>2004-02-11 07:34:59</when>
    <field_name>issue_status</field_name>
    <field_desc>Status</field_desc>
    <oldvalue>RESOLVED</oldvalue>
    <newvalue>CLOSED</newvalue>
  </activity>
</issue>
<issue status_code="200" status_message="OK">
  <issue_id>5</issue_id>
  <issue_status>CLOSED</issue_status>
  <priority>P3</priority>
  <resolution>FIXED</resolution>
  <component>glazedlists</component>
  <version>current</version>
  <rep_platform>All</rep_platform>
  <assigned_to>jessewilson</assigned_to>
  <delta_ts>20040211073533</delta_ts>
  <subcomponent>www</subcomponent>
  <reporter>jessewilson</reporter>
  <target_milestone>milestone 1</target_milestone>
  <issue_type>DEFECT</issue_type>
  <creation_ts>2004-01-15 14:40:43</creation_ts>
  <qa_contact>issues@glazedlists</qa_contact>
  <status_whiteboard></status_whiteboard>
  <votes></votes>
  <op_sys>All</op_sys>
  <short_desc>Speed up SparseLists</short_desc>
  <keywords></keywords>
  <long_desc>
   <who>jessewilson</who>
   <issue_when>2004-01-15 14:40:43</issue_when>
   <thetext>The SparseListNode's height() method slow. More formally, this method is potentially O(n) 
and it should be optimized to be O(1).

This is insignificant in small lists but huge in large lists. In my brief profiling I discovered 
that height() can consume 75% of the access time for large lists.</thetext>
  </long_desc>
  <long_desc>
   <who>jessewilson</who>
   <issue_when>2004-01-22 16:08:39</issue_when>
   <thetext>I have tuned SparseLists to use a better height() method. The height is now stored 
in the node and recalculated whenever it may have changed (as a consequence of 
insert or remove).

The performance gains are fantastic.</thetext>
  </long_desc>
  <long_desc>
   <who>jessewilson</who>
   <issue_when>2004-02-11 07:35:33</issue_when>
   <thetext>This bug has been fixed for two weeks with no problems. I am marking it closed.</thetext>
  </long_desc>
  <activity>
    <user>jessewilson</user>
    <when>2004-01-22 16:08:39</when>
    <field_name>issue_status</field_name>
    <field_desc>Status</field_desc>
    <oldvalue>NEW</oldvalue>
    <newvalue>RESOLVED</newvalue>
  </activity>
  <activity>
    <user>jessewilson</user>
    <when>2004-01-22 16:08:39</when>
    <field_name>resolution</field_name>
    <field_desc>Resolution</field_desc>
    <oldvalue></oldvalue>
    <newvalue>FIXED</newvalue>
  </activity>
  <activity>
    <user>jessewilson</user>
    <when>2004-02-11 07:35:33</when>
    <field_name>issue_status</field_name>
    <field_desc>Status</field_desc>
    <oldvalue>RESOLVED</oldvalue>
    <newvalue>CLOSED</newvalue>
  </activity>
</issue>
<issue status_code="200" status_message="OK">
  <issue_id>6</issue_id>
  <issue_status>CLOSED</issue_status>
  <priority>P3</priority>
  <resolution>INVALID</resolution>
  <component>glazedlists</component>
  <version>current</version>
  <rep_platform>All</rep_platform>
  <assigned_to>issues@glazedlists</assigned_to>
  <delta_ts>20040211073416</delta_ts>
  <subcomponent>www</subcomponent>
  <reporter>ildella</reporter>
  <target_milestone>milestone 1</target_milestone>
  <issue_type>DEFECT</issue_type>
  <creation_ts>2004-01-16 12:29:12</creation_ts>
  <qa_contact>issues@glazedlists</qa_contact>
  <status_whiteboard></status_whiteboard>
  <votes></votes>
  <op_sys>All</op_sys>
  <short_desc>MutationList return "parent" source instead of its own</short_desc>
  <keywords></keywords>
  <long_desc>
   <who>ildella</who>
   <issue_when>2004-01-16 12:29:12</issue_when>
   <thetext>MutationList getRootList was
    
    public EventList getRootList() {
    	return source;
    }

as of revision 1.3 on CVS.

In revision 1.4, it is:

    /**
     * For implementing the EventList interface. This returns the root of the
     * source list, or &lt;code&gt;this&lt;/code&gt; if this list has no source.
     */
    /*
    public EventList getRootList() {
        if(source == this) return this;
        return source.getRootList();
    }

and this broke all my code and my coomprehension of Glazed Lists.

Is this correct?</thetext>
  </long_desc>
  <long_desc>
   <who>jessewilson</who>
   <issue_when>2004-01-16 13:49:42</issue_when>
   <thetext>Forgive me for breaking your code. The newest revision in CVS is correct and the previous 
revision was a bug.

In your own code when you need the source list, you are supposed to use 'source', which 
is a protected member of the MutationList class. If you change your calls to 'getRootList()' 
with 'source', your code should continue to work as it is supposed to.


Here's why I made the change:

Glazed Lists needs to be thread-safe. Currently I have made every effort to make it totally 
thread-safe. To accomplish thread safety I need to synchronize threads while they are 
performing updates to the lists. In my original implementation, each list would be coded 
like this:
    public synchronized void notifyListUpdated()
    public synchronized void get()
Unfortunately this strategy can fail for thread safety in deadlock because the Swing thread 
can be doing a get() while the query thread is doing an update. The get() call propagates 
from the table to the filter to the sorted list and eventually to the source list, holding all 
the locks as it works. The notifyListUpdated does the opposite, starting at the source list 
and propagating through the sorted list, the filter and finally the table, attempting to 
acquire locks as it goes also. A deadlock is the inevitable result because the Swing thread 
is waiting for the query thread to release its lock on the source list while the query thread 
waits on the Swing thread to release its lock on the table.

So my naive solution failed and I realized that I needed to synchronize all lists with the 
same lock. The obvious lock to choose is the root list - the absolute source list in the tree. 
This is the list that all of the other lists depend on.

As you walk through the code, you will see that I protect against thread problems with
    synchronized(getRootList()) {
    }

But I still access the parent list with 'source'. For example, the following is cut-and-pasted 
from SortedList:

    public void setComparator(Comparator comparator) {
        synchronized(getRootList()) {
            // create the sorted list with a simple comparator
            sorted = new IndexedTree(new IndexedTreeNodeComparator(comparator));
            // create a list which knows the offsets of the indexes
            unsorted = new IndexedTree();

            // we're done if there's no elements in the source list
            if(source.size() == 0) return;

            // add all elements in the source list, in order
            for(int i = 0; i &lt; source.size(); i++) {
                IndexedTreeNode unsortedNode = unsorted.addByNode(i, this);
                insertByUnsortedNode(unsortedNode);
            }

            // notification about the big change
            updates.beginAtomicChange();
            updates.appendChange(0, size() - 1, ListChangeBlock.DELETE);
            updates.appendChange(0, size() - 1, ListChangeBlock.INSERT);
            updates.commitAtomicChange();
        }
    }

The second line is synchronized on getRootList(), but all of the calls to size() are directly 
on source.

In summary

Whenever you are synchronizing, use
    synchronized(getRootList())
but for everything else use
    source</thetext>
  </long_desc>
  <long_desc>
   <who>jessewilson</who>
   <issue_when>2004-02-11 07:34:16</issue_when>
   <thetext>This bug has been fixed for two weeks with no problems. I am marking it closed.</thetext>
  </long_desc>
  <activity>
    <user>jessewilson</user>
    <when>2004-01-16 13:49:42</when>
    <field_name>issue_status</field_name>
    <field_desc>Status</field_desc>
    <oldvalue>NEW</oldvalue>
    <newvalue>RESOLVED</newvalue>
  </activity>
  <activity>
    <user>jessewilson</user>
    <when>2004-01-16 13:49:42</when>
    <field_name>resolution</field_name>
    <field_desc>Resolution</field_desc>
    <oldvalue></oldvalue>
    <newvalue>INVALID</newvalue>
  </activity>
  <activity>
    <user>jessewilson</user>
    <when>2004-02-11 07:34:16</when>
    <field_name>issue_status</field_name>
    <field_desc>Status</field_desc>
    <oldvalue>RESOLVED</oldvalue>
    <newvalue>CLOSED</newvalue>
  </activity>
</issue>
<issue status_code="200" status_message="OK">
  <issue_id>7</issue_id>
  <issue_status>CLOSED</issue_status>
  <priority>P3</priority>
  <resolution>FIXED</resolution>
  <component>glazedlists</component>
  <version>current</version>
  <rep_platform>All</rep_platform>
  <assigned_to>jessewilson</assigned_to>
  <delta_ts>20040404145045</delta_ts>
  <subcomponent>www</subcomponent>
  <reporter>jessewilson</reporter>
  <target_milestone>milestone 1</target_milestone>
  <issue_type>ENHANCEMENT</issue_type>
  <creation_ts>2004-01-21 12:19:22</creation_ts>
  <qa_contact>issues@glazedlists</qa_contact>
  <status_whiteboard></status_whiteboard>
  <votes></votes>
  <op_sys>All</op_sys>
  <short_desc>CaseInsensitiveFilterList non-"live" mode</short_desc>
  <keywords></keywords>
  <long_desc>
   <who>jessewilson</who>
   <issue_when>2004-01-21 12:19:22</issue_when>
   <thetext>If you have a CaseInsensitiveFilterList with many entries and you filter for "foo", then the 
list will be filtered three times! Because the list is "live" it filters once after the user types 
"f", another time after they have typed "fo" and finally a third time after they have 
completed "foo".

This is great when filtering is very fast and the list is short but it leads to unnecessary 
performance lags when the list is large and filtering isn't as fast.

The CaseInsensitiveFilterList should have a non-"live" mode where the list is only filtered 
after the user presses the Enter key in the search box. There could also be a "filter" 
button to activate the filter after the filter text has been entered.</thetext>
  </long_desc>
  <long_desc>
   <who>jessewilson</who>
   <issue_when>2004-03-11 13:42:28</issue_when>
   <thetext>I've added some new methods to CaseInsensitiveFilterList:

getActionListener()
setLive(boolean)

The ActionListener can be used to trigger a refilter on a button press. 
The list also will always refilter when ENTER is pressed in the filter edit field, whether in live mode or 
not.

Finally the DocumentListener has been moved to an inner class which is a 'safer' place for it.</thetext>
  </long_desc>
  <long_desc>
   <who>jessewilson</who>
   <issue_when>2004-04-04 14:50:45</issue_when>
   <thetext>This bug has been fixed for two weeks with no problems. I am marking it closed.</thetext>
  </long_desc>
  <activity>
    <user>jessewilson</user>
    <when>2004-03-11 13:42:28</when>
    <field_name>issue_status</field_name>
    <field_desc>Status</field_desc>
    <oldvalue>NEW</oldvalue>
    <newvalue>RESOLVED</newvalue>
  </activity>
  <activity>
    <user>jessewilson</user>
    <when>2004-03-11 13:42:28</when>
    <field_name>resolution</field_name>
    <field_desc>Resolution</field_desc>
    <oldvalue></oldvalue>
    <newvalue>FIXED</newvalue>
  </activity>
  <activity>
    <user>jessewilson</user>
    <when>2004-04-04 14:50:45</when>
    <field_name>issue_status</field_name>
    <field_desc>Status</field_desc>
    <oldvalue>RESOLVED</oldvalue>
    <newvalue>CLOSED</newvalue>
  </activity>
</issue>
<issue status_code="200" status_message="OK">
  <issue_id>8</issue_id>
  <issue_status>CLOSED</issue_status>
  <priority>P3</priority>
  <resolution>FIXED</resolution>
  <component>glazedlists</component>
  <version>current</version>
  <rep_platform>All</rep_platform>
  <assigned_to>issues@glazedlists</assigned_to>
  <delta_ts>20040211073606</delta_ts>
  <subcomponent>www</subcomponent>
  <reporter>jessewilson</reporter>
  <target_milestone>milestone 1</target_milestone>
  <issue_type>DEFECT</issue_type>
  <creation_ts>2004-01-23 07:42:58</creation_ts>
  <qa_contact>issues@glazedlists</qa_contact>
  <status_whiteboard></status_whiteboard>
  <votes></votes>
  <op_sys>All</op_sys>
  <short_desc>ListChangeSequence hasNext() fails when there's no next</short_desc>
  <keywords></keywords>
  <long_desc>
   <who>jessewilson</who>
   <issue_when>2004-01-23 07:42:58</issue_when>
   <thetext>There are two things that happen when a list changes:
  - the ListChangeEvent is populated with the change information
  - the notifyListChanges() method is called on all listeners

Sometimes as a consequence of multi-threading, multiple change events are processed in 
a single notifyListChanges() methods. When the notifyListChanges() is called on a different 
thread than where the changes were created, that method is required to verify that there 
are changes left to be processed using:
    listChanges.hasNext()

This is performed by the ListTable because it receives all events on the SwingThread via 
ListChangeListenerEventThreadProxy:
    public void notifyListChanges(ListChangeEvent listChanges) {
        ...
        // when all events hae already been processed by clearing the event queue
        if(!listChanges.hasNext()) {
            return;
        ...

Unfortunately the listChanges.hasNext() method is broken, and throws an 
IndexOutOfBoundsException when there are no more changes:
java.lang.IndexOutOfBoundsException: Index: 43, Size: 43
	at java.util.ArrayList.RangeCheck(ArrayList.java:507)
	at java.util.ArrayList.get(ArrayList.java:324)
	at 
com.odellengineeringltd.glazedlists.event.ListChangeSequence.getBlockCount(ListChangeSe
quence.java:181)
	at 
com.odellengineeringltd.glazedlists.event.ListChangeEvent.hasNext(ListChangeEvent.java:
124)
	at com.odellengineeringltd.glazedlists.jtable.ListTable.notifyListChanges(ListTable.java:
158)
	at 
com.odellengineeringltd.glazedlists.event.ListChangeListenerEventThreadProxy.run(ListCha
ngeListenerEventThreadProxy.java:54)
	at java.awt.event.InvocationEvent.dispatch(InvocationEvent.java:178)
	at java.awt.EventQueue.dispatchEvent(EventQueue.java:454)
	at 
java.awt.EventDispatchThread.pumpOneEventForHierarchy(EventDispatchThread.java:201)
	at java.awt.EventDispatchThread.pumpEventsForHierarchy(EventDispatchThread.java:
151)
	at java.awt.EventDispatchThread.pumpEvents(EventDispatchThread.java:145)
	at java.awt.EventDispatchThread.pumpEvents(EventDispatchThread.java:137)
	at java.awt.EventDispatchThread.run(EventDispatchThread.java:100)</thetext>
  </long_desc>
  <long_desc>
   <who>jessewilson</who>
   <issue_when>2004-01-24 11:30:31</issue_when>
   <thetext>The ListChangeEvent now checks with the target ListChangeSequence to verify that it has 
not already reached the last atomic change in the set.

This should fix the problem as it has in my preliminary tests.</thetext>
  </long_desc>
  <long_desc>
   <who>jessewilson</who>
   <issue_when>2004-02-11 07:36:06</issue_when>
   <thetext>This bug has been fixed for two weeks with no problems. I am marking it closed.</thetext>
  </long_desc>
  <activity>
    <user>jessewilson</user>
    <when>2004-01-24 11:30:31</when>
    <field_name>issue_status</field_name>
    <field_desc>Status</field_desc>
    <oldvalue>NEW</oldvalue>
    <newvalue>RESOLVED</newvalue>
  </activity>
  <activity>
    <user>jessewilson</user>
    <when>2004-01-24 11:30:31</when>
    <field_name>resolution</field_name>
    <field_desc>Resolution</field_desc>
    <oldvalue></oldvalue>
    <newvalue>FIXED</newvalue>
  </activity>
  <activity>
    <user>jessewilson</user>
    <when>2004-02-11 07:36:06</when>
    <field_name>issue_status</field_name>
    <field_desc>Status</field_desc>
    <oldvalue>RESOLVED</oldvalue>
    <newvalue>CLOSED</newvalue>
  </activity>
</issue>
<issue status_code="200" status_message="OK">
  <issue_id>9</issue_id>
  <issue_status>CLOSED</issue_status>
  <priority>P3</priority>
  <resolution>FIXED</resolution>
  <component>glazedlists</component>
  <version>current</version>
  <rep_platform>All</rep_platform>
  <assigned_to>issues@glazedlists</assigned_to>
  <delta_ts>20040223154018</delta_ts>
  <subcomponent>www</subcomponent>
  <reporter>ildella</reporter>
  <target_milestone>milestone 1</target_milestone>
  <issue_type>DEFECT</issue_type>
  <creation_ts>2004-01-26 12:35:18</creation_ts>
  <qa_contact>issues@glazedlists</qa_contact>
  <status_whiteboard></status_whiteboard>
  <votes></votes>
  <op_sys>All</op_sys>
  <short_desc>fails to report selection event</short_desc>
  <keywords></keywords>
  <long_desc>
   <who>ildella</who>
   <issue_when>2004-01-26 12:35:18</issue_when>
   <thetext>The problem is in this code:

class ListTable 
...

    public void notifyListChanges(ListChangeEvent listChanges) {
        // for avoiding extra selection events
        ignoreSelectionEvents = true;
        // when all events hae already been processed by clearing the event queue
        if(!listChanges.hasNext()) {
            return;
        // notify all changes simultaneously
        }

it is needed to add this line

     	ignoreSelectionEvents = false;

before that return. Without that line, it could happen that
ignoreSelectionEvents remains false and selection event are no more propagated.</thetext>
  </long_desc>
  <long_desc>
   <who>jessewilson</who>
   <issue_when>2004-01-26 12:57:47</issue_when>
   <thetext>The bug has been fixed.

The bug report was very useful in helping me fix this bug quickly!</thetext>
  </long_desc>
  <long_desc>
   <who>jessewilson</who>
   <issue_when>2004-02-23 15:40:18</issue_when>
   <thetext>This bug has been fixed for two weeks with no problems. I am marking it closed.</thetext>
  </long_desc>
  <activity>
    <user>jessewilson</user>
    <when>2004-01-26 12:57:47</when>
    <field_name>issue_status</field_name>
    <field_desc>Status</field_desc>
    <oldvalue>NEW</oldvalue>
    <newvalue>RESOLVED</newvalue>
  </activity>
  <activity>
    <user>jessewilson</user>
    <when>2004-01-26 12:57:47</when>
    <field_name>resolution</field_name>
    <field_desc>Resolution</field_desc>
    <oldvalue></oldvalue>
    <newvalue>FIXED</newvalue>
  </activity>
  <activity>
    <user>jessewilson</user>
    <when>2004-02-23 15:40:18</when>
    <field_name>issue_status</field_name>
    <field_desc>Status</field_desc>
    <oldvalue>RESOLVED</oldvalue>
    <newvalue>CLOSED</newvalue>
  </activity>
</issue>
<issue status_code="200" status_message="OK">
  <issue_id>10</issue_id>
  <issue_status>CLOSED</issue_status>
  <priority>P3</priority>
  <resolution>FIXED</resolution>
  <component>glazedlists</component>
  <version>current</version>
  <rep_platform>All</rep_platform>
  <assigned_to>issues@glazedlists</assigned_to>
  <delta_ts>20040223153929</delta_ts>
  <subcomponent>www</subcomponent>
  <reporter>jessewilson</reporter>
  <target_milestone>milestone 1</target_milestone>
  <issue_type>DEFECT</issue_type>
  <creation_ts>2004-01-27 21:37:01</creation_ts>
  <qa_contact>issues@glazedlists</qa_contact>
  <status_whiteboard></status_whiteboard>
  <votes></votes>
  <op_sys>All</op_sys>
  <short_desc>IndexedTree insert and remove are too slow</short_desc>
  <keywords></keywords>
  <long_desc>
   <who>jessewilson</who>
   <issue_when>2004-01-27 21:37:01</issue_when>
   <thetext>The height() method on the IndexedTreeNode is not optimized and prevents the 
IndexedTreeNode from functioning efficiently. The method has O(n) runtime while proper 
optimization should yield O(log n) runtime.

This is because the height() method does not cache the height of the values at the nodes.

Fix the height as done for issue #5 with SparseListNode and the IndexedTree will perform 
much more efficiently.</thetext>
  </long_desc>
  <long_desc>
   <who>jessewilson</who>
   <issue_when>2004-01-28 09:54:04</issue_when>
   <thetext>I have resolved the speed issue with the IndexedTreeNode.

This will impact the SortedList and cause it to perform faster sorts!</thetext>
  </long_desc>
  <long_desc>
   <who>jessewilson</who>
   <issue_when>2004-02-23 15:39:29</issue_when>
   <thetext>This bug has been fixed for two weeks with no problems. I am marking it closed.</thetext>
  </long_desc>
  <activity>
    <user>jessewilson</user>
    <when>2004-01-28 09:54:04</when>
    <field_name>issue_status</field_name>
    <field_desc>Status</field_desc>
    <oldvalue>NEW</oldvalue>
    <newvalue>RESOLVED</newvalue>
  </activity>
  <activity>
    <user>jessewilson</user>
    <when>2004-01-28 09:54:04</when>
    <field_name>resolution</field_name>
    <field_desc>Resolution</field_desc>
    <oldvalue></oldvalue>
    <newvalue>FIXED</newvalue>
  </activity>
  <activity>
    <user>jessewilson</user>
    <when>2004-02-23 15:39:29</when>
    <field_name>issue_status</field_name>
    <field_desc>Status</field_desc>
    <oldvalue>RESOLVED</oldvalue>
    <newvalue>CLOSED</newvalue>
  </activity>
</issue>
<issue status_code="200" status_message="OK">
  <issue_id>11</issue_id>
  <issue_status>CLOSED</issue_status>
  <priority>P3</priority>
  <resolution>FIXED</resolution>
  <component>glazedlists</component>
  <version>current</version>
  <rep_platform>All</rep_platform>
  <assigned_to>issues@glazedlists</assigned_to>
  <delta_ts>20040223154221</delta_ts>
  <subcomponent>www</subcomponent>
  <reporter>philblais</reporter>
  <target_milestone>milestone 1</target_milestone>
  <issue_type>ENHANCEMENT</issue_type>
  <creation_ts>2004-01-30 06:16:51</creation_ts>
  <qa_contact>issues@glazedlists</qa_contact>
  <status_whiteboard></status_whiteboard>
  <votes></votes>
  <op_sys>All</op_sys>
  <short_desc>Expose prepareRenderer from JTable into ListTable class</short_desc>
  <keywords></keywords>
  <long_desc>
   <who>philblais</who>
   <issue_when>2004-01-30 06:16:51</issue_when>
   <thetext>I like having the ability to alternate colors on each of the rows of my tables so 
that they look more like a ledger.  Since ListTable creates the JTable object it 
makes it impossible to use this approach to render this.

I propose to expose this method into ListTable so that it can be overriden if 
necessary.</thetext>
  </long_desc>
  <long_desc>
   <who>jessewilson</who>
   <issue_when>2004-01-30 07:40:27</issue_when>
   <thetext>philblais - Glazed Lists already has a place where you can configure your table and 
prepare your renderers as necessary.

You will have implemented the interface TableFormat which contains a method 
configureTable(). This method is called after the JTable has been created and its purpose is 
to allow you to modify the table's renderers to your liking:

    /**
     * Allow the record model to customize the table to its liking
     * This method is called after the table is created so that the
     * record can ensure the table behaves appropriately. This may
     * include setting the editors and renderers for the table.
     */
    public void configureTable(JTable table);

Please call prepareRenderer() from this configureTable method and I hope you will get 
your desired results.

If my understanding of your problem is incorrect please explain why calling 
prepareRenderer() from your configureTable() is insufficient and I will make quick 
progress at getting it working for you.

Good luck with your project!</thetext>
  </long_desc>
  <long_desc>
   <who>jessewilson</who>
   <issue_when>2004-01-30 15:30:17</issue_when>
   <thetext>On 30-Jan-04, at 10:54 AM, Philippe Blais wrote:

Hi,

The way it now it won't work.  The JTable's prepareRenderer method is called
dynamically with the cell's renderer, the row index and the column index.
In my project I use the row index to decide what kind of background I want
for all the renderers on the row.

I made a quick and dirty mod to ListTable for now since I couldn't simply
subclass it, my mod looks as follows in the constructWidgets method:

--
table = new JTable(this)
{
	public Component prepareRenderer(TableCellRenderer renderer, int
rowIndex,int colIndex)
	{
		Component c = super.prepareRenderer(renderer, 
				rowIndex, colIndex);
		if (rowIndex % 2 == 0 &amp;&amp; !isCellSelected(rowIndex,
colIndex)){
		if (alternateShadingColor!=null) {
			c.setBackground(alternateShadingColor);
		} else {
			c.setBackground(getBackground());
		}
	} else {
		c.setBackground(getBackground());
	}
	
	return c;
}
--

On simple way to allow extending ListTable for this functionality would be
to delegate the creation of the table to a protected method of ListTable
that can be overridden by whoever wants to extend ListTable.

My suggestion is to change the "new JTable(this)" call to
"createTable(this)" where the method would look like:

protected JTable createTable(TableModel model) {
	return new JTable(model);
}

This way I would have the ability to use my own extended JTable.

Thanks,

Phil Blais
</thetext>
  </long_desc>
  <long_desc>
   <who>jessewilson</who>
   <issue_when>2004-01-30 15:44:58</issue_when>
   <thetext>Phil Blais - 

I have written a fix for your problem and I hope that you find it sufficient! 

But first, an explanation as to why I have not fixed your problem the way you have 
suggested. The problem with allowing the user to extend JTable is that it prevents me 
from extending JTable in the future.

My solution involves a custom renderer called StripedTableCellRenderer which I have 
added to the com.odellengineeringltd.glazedlists.jtable package. In your TableCell class 
you will need to set each column's renderer to use this StripedTableCellRenderer:

public void configureTable(JTable table) {
    Color oddColor = new java.awt.Color(234, 234, 234);
    Color evenColor = table.getBackground();
    StripedTableCellRenderer renderer = new StripedTableCellRenderer(oddColor, 
evenColor);
    for(int i = 0; i &lt; getFieldCount(); i++) {
        table.getColumnModel().getColumn(i).setCellRenderer(renderer);
    }
}

The StripedTableCellRenderer uses the default renderer from the table so classes like 
Boolean and Number should render correctly.

It is also possible to specify a base renderer to use. In this case the StripedRenderer will 
use that renderer to do the initial drawing and then paint its own stripe onto the row.

Let me know if this solution is still insufficient and I will work with you to resolve any 
outstanding problems.</thetext>
  </long_desc>
  <long_desc>
   <who>jessewilson</who>
   <issue_when>2004-02-23 15:42:21</issue_when>
   <thetext>This bug has been fixed for two weeks with no problems. I am marking it closed.</thetext>
  </long_desc>
  <activity>
    <user>jessewilson</user>
    <when>2004-01-30 07:40:27</when>
    <field_name>issue_status</field_name>
    <field_desc>Status</field_desc>
    <oldvalue>NEW</oldvalue>
    <newvalue>RESOLVED</newvalue>
  </activity>
  <activity>
    <user>jessewilson</user>
    <when>2004-01-30 07:40:27</when>
    <field_name>resolution</field_name>
    <field_desc>Resolution</field_desc>
    <oldvalue></oldvalue>
    <newvalue>INVALID</newvalue>
  </activity>
  <activity>
    <user>jessewilson</user>
    <when>2004-01-30 15:30:17</when>
    <field_name>issue_status</field_name>
    <field_desc>Status</field_desc>
    <oldvalue>RESOLVED</oldvalue>
    <newvalue>REOPENED</newvalue>
  </activity>
  <activity>
    <user>jessewilson</user>
    <when>2004-01-30 15:30:17</when>
    <field_name>resolution</field_name>
    <field_desc>Resolution</field_desc>
    <oldvalue>INVALID</oldvalue>
    <newvalue></newvalue>
  </activity>
  <activity>
    <user>jessewilson</user>
    <when>2004-01-30 15:44:58</when>
    <field_name>issue_status</field_name>
    <field_desc>Status</field_desc>
    <oldvalue>REOPENED</oldvalue>
    <newvalue>RESOLVED</newvalue>
  </activity>
  <activity>
    <user>jessewilson</user>
    <when>2004-01-30 15:44:58</when>
    <field_name>resolution</field_name>
    <field_desc>Resolution</field_desc>
    <oldvalue></oldvalue>
    <newvalue>FIXED</newvalue>
  </activity>
  <activity>
    <user>jessewilson</user>
    <when>2004-02-23 15:42:21</when>
    <field_name>issue_status</field_name>
    <field_desc>Status</field_desc>
    <oldvalue>RESOLVED</oldvalue>
    <newvalue>CLOSED</newvalue>
  </activity>
</issue>
<issue status_code="200" status_message="OK">
  <issue_id>12</issue_id>
  <issue_status>CLOSED</issue_status>
  <priority>P3</priority>
  <resolution>FIXED</resolution>
  <component>glazedlists</component>
  <version>current</version>
  <rep_platform>All</rep_platform>
  <assigned_to>issues@glazedlists</assigned_to>
  <delta_ts>20040223154108</delta_ts>
  <subcomponent>www</subcomponent>
  <reporter>ildella</reporter>
  <target_milestone>milestone 1</target_milestone>
  <issue_type>DEFECT</issue_type>
  <creation_ts>2004-01-31 06:19:21</creation_ts>
  <qa_contact>issues@glazedlists</qa_contact>
  <status_whiteboard></status_whiteboard>
  <votes></votes>
  <op_sys>All</op_sys>
  <short_desc>Problem with ListTable.getSelected() ?</short_desc>
  <keywords></keywords>
  <long_desc>
   <who>ildella</who>
   <issue_when>2004-01-31 06:19:21</issue_when>
   <thetext>Sometimes I receive this exception that seems to be connected to a problem in
getSelected() methods in ListTable.

java.lang.IndexOutOfBoundsException: cannot get from tree of size 14 at 47
	at
com.odellengineeringltd.glazedlists.util.IndexedTreeNode.getNodeWithIndex(IndexedTreeNode.java:81)
	at
com.odellengineeringltd.glazedlists.util.IndexedTree.getNode(IndexedTree.java:55)
	at com.odellengineeringltd.glazedlists.SortedList.get(SortedList.java:228)
	at
com.odellengineeringltd.glazedlists.jtable.ListTable.getSelected(ListTable.java:227)
	at
net.della.mcube.outliner.OutlinersBuilder$2.filterMatches(OutlinersBuilder.java:77)
	at
net.della.mcube.util.CustomFilteredList.filterMatches(CustomFilteredList.java:38)
	at
com.odellengineeringltd.glazedlists.AbstractFilterList.notifyListChanges(AbstractFilterList.java:93)
	at
com.odellengineeringltd.glazedlists.event.ListChangeSequence.commitAtomicChange(ListChangeSequence.java:154)
	at net.della.mcube.util.QueryList.refresh(QueryList.java:110)
	at net.della.mcube.util.QueryList$RefreshTask.run(QueryList.java:127)
	at java.util.TimerThread.mainLoop(Timer.java:432)
	at java.util.TimerThread.run(Timer.java:382)</thetext>
  </long_desc>
  <long_desc>
   <who>jessewilson</who>
   <issue_when>2004-01-31 10:56:33</issue_when>
   <thetext>This problem arises when the table selection is being accessed by a thread which is not 
the event dispatch thread. When the table selection is being modified by the event 
dispatch thread and a second thread attempts to access the selection, it is natural for the 
second thread to see an inconsistent view of the selection. This inconsistent view can 
cause unrelated exceptions to show up in other parts of the system. 


I have come up with three potential solutions to this problem:

1. Synchronize access to the table selection. The problem with this approach is that typical 
access to the table selection is done by the event dispatch thread which does not require 
synchronization. Therefore the synchronization will cause an unnecessary performance hit 
to typical use.

2. Require that all access to the table selection be performed on the event dispatch 
thread. This is how things work currently. But as is demonstrated there are cases where 
other threads such as timer threads need to access the table selection. The work around 
for this case is to use the SwingUtilities.invokeAndWait() method to schedule the selection 
access on the event dispatch thread. The biggest problem with this approach is that it adds 
complexity to the ListTable class.

3. Attempt to detect if the selection is currently being modified. This can be tested by 
whether or not the selection has a consistent state. If the state is inconsistent simply 
return null as if there was no selection.


I am trying to decide between solution two and solution three. Solution 2 will always 
return the correct value but it will also always take a long time when called by a thread 
which is not the event dispatch thread. Solution 3 will always return immediately but has 
the potential for returning the wrong value when the selection is being modified.

I will look through and continue to weight the pros and cons of each solution. Please let 
me know if you have any input which may help me make my decision.</thetext>
  </long_desc>
  <long_desc>
   <who>jessewilson</who>
   <issue_when>2004-02-01 09:42:53</issue_when>
   <thetext>I have made the getSelected() method safe to call from threads which are not the event 
dispatch thread. To do this I have made the getSelected() method use a helper class which 
will do the actual selection lookup on the event dispatch thread.

In implementing this solution I have been thinking that the ListTable class should not be 
concerned with selection.  Unfortunately I cannot remove selection from ListTable without 
breaking existing code.

In the interim I am considering making the getSelected() method deprecated with clients 
accessing the SelectionList as an alternative. The problem with this solution is that like 
getSelected(), the SelectionList is not safe to be used any thread but the event dispatch 
thread.

I will continue to think about this problem. If anyone has any suggestions I am open for 
comment.</thetext>
  </long_desc>
  <long_desc>
   <who>jessewilson</who>
   <issue_when>2004-02-23 15:41:08</issue_when>
   <thetext>This bug has been fixed for two weeks with no problems. I am marking it closed.</thetext>
  </long_desc>
  <activity>
    <user>jessewilson</user>
    <when>2004-01-31 10:56:33</when>
    <field_name>issue_status</field_name>
    <field_desc>Status</field_desc>
    <oldvalue>NEW</oldvalue>
    <newvalue>STARTED</newvalue>
  </activity>
  <activity>
    <user>jessewilson</user>
    <when>2004-02-01 09:42:53</when>
    <field_name>issue_status</field_name>
    <field_desc>Status</field_desc>
    <oldvalue>STARTED</oldvalue>
    <newvalue>RESOLVED</newvalue>
  </activity>
  <activity>
    <user>jessewilson</user>
    <when>2004-02-01 09:42:53</when>
    <field_name>resolution</field_name>
    <field_desc>Resolution</field_desc>
    <oldvalue></oldvalue>
    <newvalue>FIXED</newvalue>
  </activity>
  <activity>
    <user>jessewilson</user>
    <when>2004-02-23 15:41:08</when>
    <field_name>issue_status</field_name>
    <field_desc>Status</field_desc>
    <oldvalue>RESOLVED</oldvalue>
    <newvalue>CLOSED</newvalue>
  </activity>
</issue>
<issue status_code="200" status_message="OK">
  <issue_id>13</issue_id>
  <issue_status>CLOSED</issue_status>
  <priority>P3</priority>
  <resolution>INVALID</resolution>
  <component>glazedlists</component>
  <version>current</version>
  <rep_platform>All</rep_platform>
  <assigned_to>issues@glazedlists</assigned_to>
  <delta_ts>20040223154152</delta_ts>
  <subcomponent>www</subcomponent>
  <reporter>jessewilson</reporter>
  <target_milestone>milestone 1</target_milestone>
  <issue_type>DEFECT</issue_type>
  <creation_ts>2004-02-01 10:09:09</creation_ts>
  <qa_contact>issues@glazedlists</qa_contact>
  <status_whiteboard></status_whiteboard>
  <votes></votes>
  <op_sys>All</op_sys>
  <short_desc>ListChangeSequence grows unbounded</short_desc>
  <keywords></keywords>
  <long_desc>
   <who>jessewilson</who>
   <issue_when>2004-02-01 10:09:09</issue_when>
   <thetext>The ListChangeSequence grows as more and more atomic changes are created. For a long-
running Glazed Lists application the memory usage may become a serious performance 
problem.

The ListChangeSequence should null out atomic changes when they are no longer in use 
and shift the array list when it grows too large.</thetext>
  </long_desc>
  <long_desc>
   <who>jessewilson</who>
   <issue_when>2004-02-02 08:05:34</issue_when>
   <thetext>I performed a thorough examination of the memory usage of Glazed Lists and the 
application does not grow unbounded.

This can be verified in the code from the following lines that were cut-and-paste from 
ListChangeSequence:

        // attempt to reclaim some changes for the change pool
        int oldestRequiredChange = atomicChanges.size(); 
        for(int e = 0; e &lt; listenerEvents.size(); e++) {
            ListChangeEvent listChangeEvent = (ListChangeEvent)listenerEvents.get(e);
            int eventOldestChange = listChangeEvent.getAtomicChangeCount();
            if(eventOldestChange &lt; oldestRequiredChange) {
                oldestRequiredChange = eventOldestChange;
            }
        }
        // recycle every change that is no longer used
        for(int i = oldestChange; i &lt; oldestRequiredChange; i++) {
            List recycledChanges = (List)atomicChanges.get(i);
            changePool.addAll(recycledChanges);
            atomicChanges.set(i, null);
        }
        // now we have reclaimed all these change objects
        oldestChange = oldestRequiredChange;

I guess that when I was initially entering this bug I had forgotten that I had gotten around 
to adding this optimization. Nevertheless it is good to verify that there are no memory 
leaks when using Glazed Lists. In my simple test, Glazed Lists consumed less than 1000k 
of memory during the first 100,000 changes but consumed no additional memory for the 
following 1,000,000 changes. Therefore I conclude that memory usage does not grow 
unbounded.</thetext>
  </long_desc>
  <long_desc>
   <who>jessewilson</who>
   <issue_when>2004-02-23 15:41:52</issue_when>
   <thetext>This bug has been fixed for two weeks with no problems. I am marking it closed.</thetext>
  </long_desc>
  <activity>
    <user>jessewilson</user>
    <when>2004-02-02 08:05:34</when>
    <field_name>issue_status</field_name>
    <field_desc>Status</field_desc>
    <oldvalue>NEW</oldvalue>
    <newvalue>RESOLVED</newvalue>
  </activity>
  <activity>
    <user>jessewilson</user>
    <when>2004-02-02 08:05:34</when>
    <field_name>resolution</field_name>
    <field_desc>Resolution</field_desc>
    <oldvalue></oldvalue>
    <newvalue>INVALID</newvalue>
  </activity>
  <activity>
    <user>jessewilson</user>
    <when>2004-02-23 15:41:52</when>
    <field_name>issue_status</field_name>
    <field_desc>Status</field_desc>
    <oldvalue>RESOLVED</oldvalue>
    <newvalue>CLOSED</newvalue>
  </activity>
</issue>
<issue status_code="200" status_message="OK">
  <issue_id>14</issue_id>
  <issue_status>CLOSED</issue_status>
  <priority>P3</priority>
  <resolution>FIXED</resolution>
  <component>glazedlists</component>
  <version>current</version>
  <rep_platform>All</rep_platform>
  <assigned_to>jessewilson</assigned_to>
  <delta_ts>20040408090738</delta_ts>
  <subcomponent>www</subcomponent>
  <reporter>jessewilson</reporter>
  <target_milestone>milestone 1</target_milestone>
  <issue_type>FEATURE</issue_type>
  <creation_ts>2004-02-03 09:12:43</creation_ts>
  <qa_contact>issues@glazedlists</qa_contact>
  <status_whiteboard></status_whiteboard>
  <votes></votes>
  <op_sys>All</op_sys>
  <short_desc>JList support</short_desc>
  <keywords></keywords>
  <long_desc>
   <who>jessewilson</who>
   <issue_when>2004-02-03 09:12:43</issue_when>
   <thetext>Glazed Lists needs to support JList alongside JTable and JComboBox.

It should be very straightforward to change between JList and JTable in an application:
 * The selection interfaces should be the same
 * The renderers should be the same

From Fred at l2fprod.com:
&gt; I was looking at an equivalent of "ListTable"
&gt; but which would encapsulates a JList. Do you 
&gt; have this on your todo list? I guess it could
&gt; share code with the ListTable


This functionality should get its own package,
    com.odellengineeringltd.glazedlists.jlist
Perhaps the class name could be EventJList.</thetext>
  </long_desc>
  <long_desc>
   <who>jessewilson</who>
   <issue_when>2004-02-19 18:30:54</issue_when>
   <thetext>I've done some preliminary work on this and I've run into a few snags.

My first problem is with rendering. I cannot get the preferred width in order to render the cells 
nicely, because the getSize() methods depend on the results of the rendered cells! It also seems 
to be a lot slower than JTable when scrolling through a long list of rendered cells.

One thing that this has brought me to think about is better naming for some classes. ListTable is 
fine for an event list JTable, but the matching "ListList" does not make much sense. My working 
name is "EventJList" which I think is a decent naming convention. I am pondering what the 
consequences would be if I renamed everything in Glazed Lists to make more sense. If I were to 
do that I would probably also want to change the package names. O'Dell Engineering is now using 
a better package prefix of "ca.odell" which might in and of itself be worth the costs of migration.

Still I have users and CVS is unfriendly to directory deletes. I'll worry about that later. For now I 
get to think about how to do JLists right.</thetext>
  </long_desc>
  <long_desc>
   <who>jessewilson</who>
   <issue_when>2004-03-09 16:31:37</issue_when>
   <thetext>I have implemented EventJList. The class shares the following with ListTable:
 - SelectionListener interface
 - SelectionList / Selection Model

This class never batches groups of changes like ListTable does. It also does not use a Mutable change 
event. It may be necessary to create a mutable ListDataEvent if change event creation proves to be a 
bottleneck.

This class still does not have any extra renderer support. For now if styled rendering is necessary, the 
use of ListTable is a sufficient work around.</thetext>
  </long_desc>
  <long_desc>
   <who>jessewilson</who>
   <issue_when>2004-04-08 09:07:38</issue_when>
   <thetext>This bug has been fixed for two weeks with no problems. I am marking it closed.</thetext>
  </long_desc>
  <activity>
    <user>jessewilson</user>
    <when>2004-02-19 18:30:54</when>
    <field_name>issue_status</field_name>
    <field_desc>Status</field_desc>
    <oldvalue>NEW</oldvalue>
    <newvalue>STARTED</newvalue>
  </activity>
  <activity>
    <user>jessewilson</user>
    <when>2004-03-09 16:31:37</when>
    <field_name>issue_status</field_name>
    <field_desc>Status</field_desc>
    <oldvalue>STARTED</oldvalue>
    <newvalue>RESOLVED</newvalue>
  </activity>
  <activity>
    <user>jessewilson</user>
    <when>2004-03-09 16:31:37</when>
    <field_name>resolution</field_name>
    <field_desc>Resolution</field_desc>
    <oldvalue></oldvalue>
    <newvalue>FIXED</newvalue>
  </activity>
  <activity>
    <user>jessewilson</user>
    <when>2004-04-08 09:07:38</when>
    <field_name>issue_status</field_name>
    <field_desc>Status</field_desc>
    <oldvalue>RESOLVED</oldvalue>
    <newvalue>CLOSED</newvalue>
  </activity>
</issue>
<issue status_code="200" status_message="OK">
  <issue_id>15</issue_id>
  <issue_status>CLOSED</issue_status>
  <priority>P3</priority>
  <resolution>FIXED</resolution>
  <component>glazedlists</component>
  <version>current</version>
  <rep_platform>All</rep_platform>
  <assigned_to>jessewilson</assigned_to>
  <delta_ts>20040309163956</delta_ts>
  <subcomponent>www</subcomponent>
  <reporter>jessewilson</reporter>
  <target_milestone>milestone 1</target_milestone>
  <issue_type>DEFECT</issue_type>
  <creation_ts>2004-02-10 08:48:25</creation_ts>
  <qa_contact>issues@glazedlists</qa_contact>
  <status_whiteboard></status_whiteboard>
  <votes></votes>
  <op_sys>All</op_sys>
  <short_desc>Inserted items become selected</short_desc>
  <keywords></keywords>
  <long_desc>
   <who>jessewilson</who>
   <issue_when>2004-02-10 08:48:25</issue_when>
   <thetext>I am delighted with the performance, flexibility and ease of use of your platform, which I am 
currently evaluating for use in a table intensive application for my employer.

Our application needs to display tabular data which gets notified through JMS. That means, 
ultimately, that data arrives via a callback method in out code. I am therefore using a 
BasicEventList as base list, encapsulated in a SortedList and a subclass of AbstractFilterList as a 
means of providing the functionality (sorting &amp; filtering by various criteria) that we need.

The only problem so far arises with keeping selected rows between data insertions. I set the 
underlying table selection model to ListSelectionModel.MULTIPLE_INTERVAL_SELECTION (anyway, 
as it is the default value). A thread keeps adding rows to the table, at a rate of 10 per second (to 
test performance). I have noticed that whenever I select a row, further row insertions may 
modify the number of selected rows. In particular, if a new row has the same internal index as 
the currently selected one, it is guaranteed I will end up with two selected rows.

That seems to be your intended behaviour as per the documentation of the class SelectionList; 
however, I tried to modify it in order to suppress this behaviour to no avail. In particular, I 
suppressed the lines marked inside SelectionList.notifyListChanges():
// when an element is inserted, it is selected if its index was selected
} else if(changeType == ListChangeBlock.INSERT) {
    // when selected, add the flag and fire a selection event
    if(previouslySelected) {
        flagList.add(index, Boolean.TRUE); // &lt;--- SUPRESS
        updates.appendChange(previousSelectionIndex, ListChangeBlock.INSERT); // &lt;--- SUPRESS
    // when not selected, just add the space
    } else {
        flagList.add(index, null);
    }

I tried other changes, including the method SelectionList.valueChanged(). Do you have any 
suggestion to solve this problem? Is it a bug in your code? In that case, I'd be willing to help and 
contribute back to your project any bugfixes I develop. I can also provide you with my testing 
code, but at this stage it's really simple: the thread inserting fake data rows does so in an 
invokeLater() block, and uses a java.util.Timer for scheduling data feed.

The problem does not manifest when I set the table selection model to 
ListSelectionModel.SINGLE_SELECTION, by the way.

Thank you for your time and for providing the Java Community with such a promising piece of 
work.

Yours
Iván Rivera Rodríguez</thetext>
  </long_desc>
  <long_desc>
   <who>jessewilson</who>
   <issue_when>2004-02-10 08:58:51</issue_when>
   <thetext>Iván -

The current behaviour is "as designed" but I agree that there may be a better way to solve this 
problem.

This behaviour is the same as the behaviour of a simple JTable (ie. no Glazed Lists). When JTable 
receives in insert at some index, say i, then the newly inserted row will be selected only if row i 
was selected before the insertion. This behaviour has some nice properties: values inserted 
within a range of selected values will themselves become selected.

But I also agree that this behaviour can be problematic. I think the solution is to add an extra 
"mode" to the SelectionList. The new mode will be as you describe. Inserted values will never be 
selected until done so explicitly by the user.

Due to constraints at school and at work I will be unable to add this functionality until at least 
February 14th, 2004. In the worst case it will take until February 21st to complete. Hopefully then 
I will get something working that solves this problem!</thetext>
  </long_desc>
  <long_desc>
   <who>jessewilson</who>
   <issue_when>2004-02-12 08:58:18</issue_when>
   <thetext>According to the J2SE 1.4.1 API for DefaultListSelectionModel:
"If the value at index is itself selected and the selection mode is not SINGLE_SELECTION, set all of 
the newly inserted items as selected.  Otherwise leave them unselected. "
http://java.sun.com/j2se/1.4.1/docs/api/javax/swing/
DefaultListSelectionModel.html#insertIndexInterval(int,%20int,%20boolean)

I have tested some of the simple ways to solve this problem and I do not think that they will work 
elegantly. The problem is that I need to undo the selection which is added by 
DefaultListSelectionModel. This would be trivial except that the ListSelectionModel fires events that 
also need to be done and undone.

I am considering changing the Interface of SelectionList, to become a ListSelectionModel and 
EventList simultaneously. This approach is complex but appropriate as the SelectionList already 
tracks the table selection.

I will continue to review my options but for now it looks like implementing ListSelectionModel is my 
best bet.</thetext>
  </long_desc>
  <long_desc>
   <who>jessewilson</who>
   <issue_when>2004-02-15 16:02:14</issue_when>
   <thetext>I have solved the problem by implementing ListSelectionModel. Implementing this class was 
difficult as the interface specification was not explicit enough for the behaviour in certain cases. I 
think that the behaviour of my ListSelectionModel should be the same as the J2SE 1.4 
DefaultListSelectionModel. If you discover a descrepancy, let me know.

This new ListSelectionModel has a new mode for solving this problem 
"MULTIPLE_INTERVAL_SELECTION_DEFENSIVE". The new mode is the default list selection mode. 

My ListSelectionModel is fully capable of switching between different modes and retains the 
appropriate selection when the mode changes. To test this, there is a commented out block of 
code in ProgrammingLanguageBrowser.java that provides a JComboBox to switch between 
different ListSelectionModel modes.

I hope this fix helps, it took quite a bit of code to make it work - 653 lines!</thetext>
  </long_desc>
  <long_desc>
   <who>jessewilson</who>
   <issue_when>2004-02-16 09:38:36</issue_when>
   <thetext>From Iván Rivera:

Thank you very much. I had also some time to work on the issue last Friday and came up with a 
subclass of javax.swing.DefaultListSelectionModel which undoes the selection, without caring for 
events generated. I append a copy to this mail for you to examine, as it seems to correct the 
(Swing-default) behaviour.

You are right about the event handling problem, but it doesn't seem to be causing troubles in my 
test benchmark. Perhaps it's just a matter of performance. Anyway, your solution is surely more 
elegant. I won't be able to see your code until this night at home, since at work I'm behind an 
extremely restrictive firewall which doesn't even allow SSH tunneling for CVS checkout.

I'm working in some components to enable automatic width adjustment for columns based on 
content and column hiding. I hope to be able to contribute the code once I'm done (this week, 
most likely).

Once again, thanks for your interest.

Yours,

Iván Rivera</thetext>
  </long_desc>
  <long_desc>
   <who>jessewilson</who>
   <issue_when>2004-03-09 16:39:56</issue_when>
   <thetext>This bug has been fixed for two weeks with no problems. I am marking it closed.</thetext>
  </long_desc>
  <activity>
    <user>jessewilson</user>
    <when>2004-02-10 08:58:51</when>
    <field_name>issue_status</field_name>
    <field_desc>Status</field_desc>
    <oldvalue>NEW</oldvalue>
    <newvalue>STARTED</newvalue>
  </activity>
  <activity>
    <user>jessewilson</user>
    <when>2004-02-15 16:02:14</when>
    <field_name>issue_status</field_name>
    <field_desc>Status</field_desc>
    <oldvalue>STARTED</oldvalue>
    <newvalue>RESOLVED</newvalue>
  </activity>
  <activity>
    <user>jessewilson</user>
    <when>2004-02-15 16:02:14</when>
    <field_name>resolution</field_name>
    <field_desc>Resolution</field_desc>
    <oldvalue></oldvalue>
    <newvalue>FIXED</newvalue>
  </activity>
  <activity>
    <user>jessewilson</user>
    <when>2004-03-09 16:39:56</when>
    <field_name>issue_status</field_name>
    <field_desc>Status</field_desc>
    <oldvalue>RESOLVED</oldvalue>
    <newvalue>CLOSED</newvalue>
  </activity>
</issue>
<issue status_code="200" status_message="OK">
  <issue_id>16</issue_id>
  <issue_status>CLOSED</issue_status>
  <priority>P3</priority>
  <resolution>FIXED</resolution>
  <component>glazedlists</component>
  <version>current</version>
  <rep_platform>All</rep_platform>
  <assigned_to>issues@glazedlists</assigned_to>
  <delta_ts>20040309164036</delta_ts>
  <subcomponent>www</subcomponent>
  <reporter>jessewilson</reporter>
  <target_milestone>milestone 1</target_milestone>
  <issue_type>DEFECT</issue_type>
  <creation_ts>2004-02-11 07:14:58</creation_ts>
  <qa_contact>issues@glazedlists</qa_contact>
  <status_whiteboard></status_whiteboard>
  <votes></votes>
  <op_sys>All</op_sys>
  <short_desc>No removeSelectionListener() method in ListTable</short_desc>
  <keywords></keywords>
  <long_desc>
   <who>jessewilson</who>
   <issue_when>2004-02-11 07:14:58</issue_when>
   <thetext>Hi,

at minimum the ListTable has no removeSelectionListener(SelectionListener)
method ...

Any plans to correct this?

Cheers,

Joern</thetext>
  </long_desc>
  <long_desc>
   <who>jessewilson</who>
   <issue_when>2004-02-11 07:21:49</issue_when>
   <thetext>The method had been omitted in error.

I have added it to the latest revision in CVS.</thetext>
  </long_desc>
  <long_desc>
   <who>jessewilson</who>
   <issue_when>2004-03-09 16:40:36</issue_when>
   <thetext>This bug has been fixed for two weeks with no problems. I am marking it closed.</thetext>
  </long_desc>
  <activity>
    <user>jessewilson</user>
    <when>2004-02-11 07:21:49</when>
    <field_name>issue_status</field_name>
    <field_desc>Status</field_desc>
    <oldvalue>NEW</oldvalue>
    <newvalue>RESOLVED</newvalue>
  </activity>
  <activity>
    <user>jessewilson</user>
    <when>2004-02-11 07:21:49</when>
    <field_name>resolution</field_name>
    <field_desc>Resolution</field_desc>
    <oldvalue></oldvalue>
    <newvalue>FIXED</newvalue>
  </activity>
  <activity>
    <user>jessewilson</user>
    <when>2004-03-09 16:40:36</when>
    <field_name>issue_status</field_name>
    <field_desc>Status</field_desc>
    <oldvalue>RESOLVED</oldvalue>
    <newvalue>CLOSED</newvalue>
  </activity>
</issue>
<issue status_code="200" status_message="OK">
  <issue_id>17</issue_id>
  <issue_status>CLOSED</issue_status>
  <priority>P1</priority>
  <resolution>FIXED</resolution>
  <component>glazedlists</component>
  <version>current</version>
  <rep_platform>All</rep_platform>
  <assigned_to>jessewilson</assigned_to>
  <delta_ts>20040309163907</delta_ts>
  <subcomponent>www</subcomponent>
  <reporter>jessewilson</reporter>
  <target_milestone>milestone 1</target_milestone>
  <issue_type>DEFECT</issue_type>
  <creation_ts>2004-02-23 12:35:47</creation_ts>
  <qa_contact>issues@glazedlists</qa_contact>
  <status_whiteboard></status_whiteboard>
  <votes></votes>
  <op_sys>All</op_sys>
  <short_desc>Selection concurrency ArrayIndexOutOfBoundsException</short_desc>
  <keywords></keywords>
  <long_desc>
   <who>jessewilson</who>
   <issue_when>2004-02-23 12:35:47</issue_when>
   <thetext>I got the following exception:

[tasks] Interrupting worker thread to run Adding Article
apple.awt.EventQueueExceptionHandler Caught Throwable : 
java.lang.ArrayIndexOutOfBoundsException: Cannot get selection index 0, list size 0
        at 
com.odellengineeringltd.glazedlists.listselectionmodel.SelectionModelEventList$EventListSelectionMode
l.isSelectedIndex(SelectionModelEventList.java:505)
        at javax.swing.JTable.isRowSelected(JTable.java:1451)
        at javax.swing.JTable.isCellSelected(JTable.java:1481)
        at javax.swing.JTable.prepareRenderer(JTable.java:3725)
        at javax.swing.plaf.basic.BasicTableUI.paintCell(BasicTableUI.java:1149)
        at javax.swing.plaf.basic.BasicTableUI.paintCells(BasicTableUI.java:1051)
        at javax.swing.plaf.basic.BasicTableUI.paint(BasicTableUI.java:974)
        at javax.swing.plaf.ComponentUI.update(ComponentUI.java:142)
        at javax.swing.JComponent.paintComponent(JComponent.java:541)
        at javax.swing.JComponent.paint(JComponent.java:808)
        at javax.swing.JComponent._paintImmediately(JComponent.java:4695)
        at javax.swing.JComponent.paintImmediately(JComponent.java:4488)
        at javax.swing.RepaintManager.paintDirtyRegions(RepaintManager.java:410)
        at 
javax.swing.SystemEventQueueUtilities$ComponentWorkRequest.run(SystemEventQueueUtilities.java:
117)
        at java.awt.event.InvocationEvent.dispatch(InvocationEvent.java:178)
        at java.awt.EventQueue.dispatchEvent(EventQueue.java:454)
        at java.awt.EventDispatchThread.pumpOneEventForHierarchy(EventDispatchThread.java:234)
        at java.awt.EventDispatchThread.pumpEventsForHierarchy(EventDispatchThread.java:184)
        at java.awt.EventDispatchThread.pumpEvents(EventDispatchThread.java:178)
        at java.awt.EventDispatchThread.pumpEvents(EventDispatchThread.java:170)
        at java.awt.EventDispatchThread.run(EventDispatchThread.java:100)
apple.awt.EventQueueExceptionHandler Caught Throwable : 
java.lang.ArrayIndexOutOfBoundsException: Cannot get selection index 0, list size 0
        at 
com.odellengineeringltd.glazedlists.listselectionmodel.SelectionModelEventList$EventListSelectionMode
l.isSelectedIndex(SelectionModelEventList.java:505)
        at javax.swing.JTable.isRowSelected(JTable.java:1451)
        at javax.swing.JTable.isCellSelected(JTable.java:1481)
        at javax.swing.JTable.prepareRenderer(JTable.java:3725)
        at javax.swing.plaf.basic.BasicTableUI.paintCell(BasicTableUI.java:1149)
        at javax.swing.plaf.basic.BasicTableUI.paintCells(BasicTableUI.java:1051)
        at javax.swing.plaf.basic.BasicTableUI.paint(BasicTableUI.java:974)
        at javax.swing.plaf.ComponentUI.update(ComponentUI.java:142)
        at javax.swing.JComponent.paintComponent(JComponent.java:541)
        at javax.swing.JComponent.paint(JComponent.java:808)
        at javax.swing.JComponent.paintChildren(JComponent.java:647)
        at javax.swing.JComponent.paint(JComponent.java:817)
        at javax.swing.JViewport.paint(JViewport.java:774)
        at javax.swing.JComponent.paintChildren(JComponent.java:647)
        at javax.swing.JComponent.paint(JComponent.java:817)
        at javax.swing.JComponent._paintImmediately(JComponent.java:4695)
        at javax.swing.JComponent.paintImmediately(JComponent.java:4488)
        at javax.swing.RepaintManager.paintDirtyRegions(RepaintManager.java:410)
        at 
javax.swing.SystemEventQueueUtilities$ComponentWorkRequest.run(SystemEventQueueUtilities.java:
117)
        at java.awt.event.InvocationEvent.dispatch(InvocationEvent.java:178)
        at java.awt.EventQueue.dispatchEvent(EventQueue.java:454)
        at java.awt.EventDispatchThread.pumpOneEventForHierarchy(EventDispatchThread.java:234)
        at java.awt.EventDispatchThread.pumpEventsForHierarchy(EventDispatchThread.java:184)
        at java.awt.EventDispatchThread.pumpEvents(EventDispatchThread.java:178)
        at java.awt.EventDispatchThread.pumpEvents(EventDispatchThread.java:170)
        at java.awt.EventDispatchThread.run(EventDispatchThread.java:100)</thetext>
  </long_desc>
  <long_desc>
   <who>jessewilson</who>
   <issue_when>2004-02-23 15:17:31</issue_when>
   <thetext>The lists can get out of sync while changes are pending in the event queue. The ListSelectionModel 
must not throw an exception because it is possible that the lists are simply out of sync and that when 
the event queue is processed they will come back into sync.

This has been fixed so that the SelectionModel does not throw an exception in the possiblility that the 
lists are simply out of sync.

One unfortunate side effect is that the ListSelectionModel now cannot provide warning as to whether 
this method is actually being called in error.</thetext>
  </long_desc>
  <long_desc>
   <who>jessewilson</who>
   <issue_when>2004-03-09 16:39:07</issue_when>
   <thetext>This bug has been fixed for two weeks with no problems. I am marking it closed.</thetext>
  </long_desc>
  <activity>
    <user>jessewilson</user>
    <when>2004-02-23 15:17:31</when>
    <field_name>issue_status</field_name>
    <field_desc>Status</field_desc>
    <oldvalue>NEW</oldvalue>
    <newvalue>RESOLVED</newvalue>
  </activity>
  <activity>
    <user>jessewilson</user>
    <when>2004-02-23 15:17:31</when>
    <field_name>resolution</field_name>
    <field_desc>Resolution</field_desc>
    <oldvalue></oldvalue>
    <newvalue>FIXED</newvalue>
  </activity>
  <activity>
    <user>jessewilson</user>
    <when>2004-03-09 16:39:07</when>
    <field_name>issue_status</field_name>
    <field_desc>Status</field_desc>
    <oldvalue>RESOLVED</oldvalue>
    <newvalue>CLOSED</newvalue>
  </activity>
</issue>
<issue status_code="200" status_message="OK">
  <issue_id>18</issue_id>
  <issue_status>CLOSED</issue_status>
  <priority>P3</priority>
  <resolution>FIXED</resolution>
  <component>glazedlists</component>
  <version>current</version>
  <rep_platform>All</rep_platform>
  <assigned_to>jessewilson</assigned_to>
  <delta_ts>20040404144944</delta_ts>
  <subcomponent>www</subcomponent>
  <reporter>jessewilson</reporter>
  <target_milestone>milestone 1</target_milestone>
  <issue_type>DEFECT</issue_type>
  <creation_ts>2004-03-08 14:53:47</creation_ts>
  <qa_contact>issues@glazedlists</qa_contact>
  <status_whiteboard></status_whiteboard>
  <votes></votes>
  <op_sys>All</op_sys>
  <short_desc>set(), add(), remove() etc. not implemented</short_desc>
  <keywords></keywords>
  <long_desc>
   <who>jessewilson</who>
   <issue_when>2004-03-08 14:53:47</issue_when>
   <thetext>Glazed Lists does not support remove() on FilterLists. It simply throws an Exception.

Glazed Lists should support remove(). It should also support set().

To provide protection, there should be a MutationList called ReadOnlyList that throws an exception 
upon a remove() or a set.</thetext>
  </long_desc>
  <long_desc>
   <who>jessewilson</who>
   <issue_when>2004-03-09 08:46:37</issue_when>
   <thetext>The following methods that modify lists should be implemented: set(), add(), remove() and clear().

Implementing these is not straightforward because we want to modify the model indirectly by calling 
these methods upon the view. Here are some observations:

BasicEventList:
Already supports modifying methods.

QueryList:
Not directly modifyable. Objects created or modified externally can currently be updated via 
notifyObjectUpdated(). This is appropriate.

SortedList:
Methods called with an index such as set(index, value) and add(index, value) will have unpredictable 
results. This is because the modified/inserted objects may be sorted into a different index than that 
specified. This is acceptable but should be documented.

FilteredList:
The add(index, value) method is ambiguous. This is because there may be several filtered-out indicies 
in the source list that will have the same filtered index. I think the best approach is to insert at the 
highest index that will satisfy the specified index.
The add() and set() methods may cause an object to become filtered. This is acceptable but should be 
documented.

FreezableList:
Changes may do different things in different states. This is nonintuitive and could be 
troublesome. For example, when a list is frozen changes can only applied to a local copy. When the list 
is not frozen changes should propagate to parente lists. Therefore I recommend that changes are only 
allowed in the not frozen state. Otherwise an IllegalStateException should be thrown.

SelectionList:
This is not clearly defined. It may be intuitive that remove() either removes the selection or that 
remove() actually removes an element from the source list. But add() can only add an element to the 
source list because it is unnatural to use add() to perform selection by value and not index. Therefore 
add() and remove() will modify the source list.

MutationList:
This should continue to throw MethodNotSupportedException for mutator methods. It may be desirable 
to make some methods use others such as clear() calling remove() in sequence in order to simplify 
writing extending classes.</thetext>
  </long_desc>
  <long_desc>
   <who>jessewilson</who>
   <issue_when>2004-03-12 09:06:50</issue_when>
   <thetext>Daniel Bonin and I were discussing modifyable views and we came up with some observations. When 
using FilterList, SortedList or the like, you can have inconsistent behaviour. For example, the following 
code wil fail.

list x = ...
x.add(0, "Jesse");
assert("Jesse".equals(x.get(0));

This can fail because the inserted value "Jesse" gets filtered out or sorted to a different location.

Our solution: a happy list. The happy list "fakes" success as the method directed. It basically keeps 
track of local changes to make the changes appear consistent. This can be used with GUIs to allow the 
user to verify their modifications without losing the filtering and sorting. 

The happy list will be called "DeltaList" and it will keep track of both the source list and a set of deltas 
that have been performed. When an insert at x occurs, the delta list simulates that the insert occured at 
x, even if the insert was sorted or filtered to a different location.</thetext>
  </long_desc>
  <long_desc>
   <who>jessewilson</who>
   <issue_when>2004-03-15 12:11:59</issue_when>
   <thetext>I have created a new class "WritableMutationList" that provides these services to lists that extend it. It 
requires that lists implement two additional methods:
 - isWritable() returns true if the list is accepting changes at this time
 - getSourceIndex() gets the index from the source list for the corresponding index in the mutated list

This requires that there is a 1:1 correspondence between indicies in the mutated list and the indicies in 
the source list. This will not work for lists that combine source values in the mutated view.

To complete the fix, I must implement a ReadOnlyList mutated list and a DeltaList. I will also need to do 
a bunch of testing to verify that this works.</thetext>
  </long_desc>
  <long_desc>
   <who>jessewilson</who>
   <issue_when>2004-03-15 12:51:43</issue_when>
   <thetext>I've added a ReadOnlyList - now all that's left is DeltaList.

...And LOTS of testing!</thetext>
  </long_desc>
  <long_desc>
   <who>jessewilson</who>
   <issue_when>2004-03-18 15:07:46</issue_when>
   <thetext>I added test methods to SortedList and CaseInsensitiveFilterList and have gained confidence in my 
implementation of the set(), add(), remove(), clear() etc. methods.

The DeltaList has been moved to a separate issue, issue 24.
https://glazedlists.dev.java.net/issues/show_bug.cgi?id=24</thetext>
  </long_desc>
  <long_desc>
   <who>jessewilson</who>
   <issue_when>2004-04-04 14:49:44</issue_when>
   <thetext>This bug has been fixed for two weeks with no problems. I am marking it closed.</thetext>
  </long_desc>
  <activity>
    <user>jessewilson</user>
    <when>2004-03-09 08:46:37</when>
    <field_name>issue_status</field_name>
    <field_desc>Status</field_desc>
    <oldvalue>NEW</oldvalue>
    <newvalue>STARTED</newvalue>
  </activity>
  <activity>
    <user>jessewilson</user>
    <when>2004-03-09 08:46:37</when>
    <field_name>short_desc</field_name>
    <field_desc>Summary</field_desc>
    <oldvalue>remove() not implemented</oldvalue>
    <newvalue>set(), add(), remove() etc. not implemented</newvalue>
  </activity>
  <activity>
    <user>jessewilson</user>
    <when>2004-03-18 15:07:46</when>
    <field_name>issue_status</field_name>
    <field_desc>Status</field_desc>
    <oldvalue>STARTED</oldvalue>
    <newvalue>RESOLVED</newvalue>
  </activity>
  <activity>
    <user>jessewilson</user>
    <when>2004-03-18 15:07:46</when>
    <field_name>resolution</field_name>
    <field_desc>Resolution</field_desc>
    <oldvalue></oldvalue>
    <newvalue>FIXED</newvalue>
  </activity>
  <activity>
    <user>jessewilson</user>
    <when>2004-04-04 14:49:44</when>
    <field_name>issue_status</field_name>
    <field_desc>Status</field_desc>
    <oldvalue>RESOLVED</oldvalue>
    <newvalue>CLOSED</newvalue>
  </activity>
</issue>
<issue status_code="200" status_message="OK">
  <issue_id>19</issue_id>
  <issue_status>NEW</issue_status>
  <priority>P3</priority>
  <resolution></resolution>
  <component>glazedlists</component>
  <version>current</version>
  <rep_platform>All</rep_platform>
  <assigned_to>jessewilson</assigned_to>
  <delta_ts>20040309085347</delta_ts>
  <subcomponent>www</subcomponent>
  <reporter>jessewilson</reporter>
  <target_milestone>milestone 1</target_milestone>
  <issue_type>FEATURE</issue_type>
  <creation_ts>2004-03-09 08:53:47</creation_ts>
  <qa_contact>issues@glazedlists</qa_contact>
  <status_whiteboard></status_whiteboard>
  <votes></votes>
  <op_sys>All</op_sys>
  <short_desc>Glazed lists on the network</short_desc>
  <keywords></keywords>
  <long_desc>
   <who>jessewilson</who>
   <issue_when>2004-03-09 08:53:47</issue_when>
   <thetext>As documented in the developer newsgroup, I want to build a model that allows list changes to be 
distributed across the network.

https://glazedlists.dev.java.net/servlets/ReadMsg?list=dev&amp;msgNo=11
https://glazedlists.dev.java.net/servlets/ReadMsg?list=dev&amp;msgNo=12

I will create a descrete event simulation model in order to test out what network strategies are most 
effective. Also I think that this package should be implemented exclusively using the buffered java.nio 
package if possible.</thetext>
  </long_desc>
</issue>
<issue status_code="200" status_message="OK">
  <issue_id>20</issue_id>
  <issue_status>RESOLVED</issue_status>
  <priority>P5</priority>
  <resolution>FIXED</resolution>
  <component>glazedlists</component>
  <version>current</version>
  <rep_platform>All</rep_platform>
  <assigned_to>jessewilson</assigned_to>
  <delta_ts>20040602230950</delta_ts>
  <subcomponent>www</subcomponent>
  <reporter>jessewilson</reporter>
  <target_milestone>milestone 1</target_milestone>
  <issue_type>DEFECT</issue_type>
  <creation_ts>2004-03-09 09:12:58</creation_ts>
  <qa_contact>issues@glazedlists</qa_contact>
  <status_whiteboard></status_whiteboard>
  <votes></votes>
  <op_sys>All</op_sys>
  <short_desc>Refactor package and class names</short_desc>
  <keywords></keywords>
  <blocks>41</blocks>
  <long_desc>
   <who>jessewilson</who>
   <issue_when>2004-03-09 09:12:58</issue_when>
   <thetext>These changes make the code easier for new users at the expense of requiring existing users to change 
their imports. Therefore the changes should be made very carefully. If possible a tool should be 
referenced to automatically convert .java files for existing users.

First off, com.odellengineeringltd.glazedlists is a mouthful. This should be changed to O'Dell 
Engineering's new standard package, ca.odell.glazedlists.

...glazedlists.listselectionmodel should be renamed to ...glazedlists.selection.

In ...glazedlists.jtable:
  ListTable should be EventJTable
  SelectionListener should be moved to ...glazedlists.selection
  BasicSelectionListener should be moved to ...glazedlists.selection

Finally the following classes should be verified working or removed:
...glazedlists.jtextfield.ArrayStringCompleter
...glazedlists.jtextfield.CompletedField
...glazedlists.jtextfield.ComponentCaution
...glazedlists.jtextfield.ListStringCompleter
...glazedlists.jtextfield.StringCompleter
...glazedlists.jtextfield.ValidatedField
...glazedlists.jtable.StyledDocumentEditor
...glazedlists.jtable.WritableListTable
...glazedlists.jtable.WritableTableFormat
...glazedlists.query.QueryListManager

As I have already said, these changes will ruin Glazed Lists programs. Therefore all Glazed Lists users 
should be notified before making any changes and copies of the Glazed Lists jar file and source should 
be permanently archived for users with these packages.</thetext>
  </long_desc>
  <long_desc>
   <who>jessewilson</who>
   <issue_when>2004-03-21 10:05:08</issue_when>
   <thetext>When I fix this bug I will be breaking compatibility. Other compatibility-breaking changes should all be 
performed at the exact same time.

Another compatibility-breaking change is changing the concurrency strategy. The current strategy uses 
simple global synchronization, where a better solution will use Reader/Writer locks. This will be 
necessary to resolve Issue 25.</thetext>
  </long_desc>
  <long_desc>
   <who>jessewilson</who>
   <issue_when>2004-04-17 17:48:07</issue_when>
   <thetext>Here's my current ideas on what to do with each class. My goal is to simplify Glazed Lists by removing 
everything that is not essential. 

AbstractFilterList - ok
ArrayStringCompleter - remove, this class is not within the scope of the project
BasicEventList - ok
BasicSelectionListener - remove, this class is simple in implementation and limited in use
BoundedMap - remove, this class is no longer used
CachingList - ok
CaseInsensitiveFilterList - SubstringFilterList, have case toggle options
CharacteristicList - rename ?
ComparableComparator - ok
ComparatorChain - ok
CompletedField - remove, not within scope
ComponentCaution - remove, not within scope
CompositeList - ok
DynamicQueryList - replace with a different 'query' list that does not use the Query class, just a 
setCollection() method
EmptyQuery - remove
EventJList - replace with a EventListModel
EventList - ok
EventListIterator - ok
ExitOnCloseHandler - remove, not in scope
Filterable - remove? Filterator only may be a better approach
Filterator - rename TextFilterator
FreezableList - ok
IconComboBoxRenderer - remove, not within scope
IndexedTree - ok
IndexedTreeNode - ok
ListChangeBlock - make package-scope, move constants DELETE, INSERT to ListChangeEvent class
ListChangeEvent - ok, add methods to get the source list and target listener
ListChangeListener - ok, change notifyListChanges to listChanged
ListChangeListenerEventThreadProxy - ok
ListChangeListenerWeakReferenceProxy - ok
ListChangeSequence - ok, maybe rename to ListChangeEventHelper or something
ListComboBoxModel - ok
ListStringCompleter - remove, out of scope
ListTable - replace with EventListTableModel
MutableListDataEvent - ok, make package-scope
MutableTableModelEvent - ok, make package-scope
MutationList - rename. the renamed list could be "DecoratorList" or something else
PeriodicQueryList - remove, see DynamicQueryList
ProgrammingLanguageBrowser - ok
ProgrammingLanguageNameComparator  - ok
ProgrammingLanguageTableCell  - ok
ProgrammingLanguageYearComparator  - ok
Query - remove, see DynamicQueryList
QueryList - replace as per DynamicQueryList
QueryListManager - remove
ReadOnlyList - ok
ReverseComparator - ok
SelectionList - remove
SelectionListener - ok? maybe remove due to models, consider more flexible selection events
SelectionModelEventList - ok
SelectionNotifier - package private
SortedList - ok
SparseList - ok
StringCompleter - remove
StripedTableCellRenderer - not really in scope, but keep it anyway
StyledDocumentEditor - remove
StyledDocumentRenderer - not really in scope, but keep it anyway, adjust built-in forms
SubEventList - ok
TableComparatorChooser - ok
TableComparatorSelector - remove
TableFormat - rename um TableColumnFormat maybe? remove configureTable for new model-
approach
TaskQueryList - remove, see DynamicQueryList
UniqueList - ok
ValidatedField - remove
WritableListTable - replace with methods in TableFormat
WritableMutationList - remove, replace with more powerful MutationList
WritableTableFormat - remove
</thetext>
  </long_desc>
  <long_desc>
   <who>jessewilson</who>
   <issue_when>2004-05-27 10:42:05</issue_when>
   <thetext>Some other things I think we should go over for this issue:
 - verify standard copyright header
 - classes should be final

To reduce the number of visible classes and therefore simplify Glazed Lists:
 - all *List classes should be in the main package
 - no support classes should be public
 - Swing classes in swing package
</thetext>
  </long_desc>
  <long_desc>
   <who>jessewilson</who>
   <issue_when>2004-05-27 11:14:21</issue_when>
   <thetext>Two other things I thought of to verify:
 - imports are clean &amp; straightforward &amp; necessary
 - there is a thread-safety warning in Javadoc for all thread-unsafe classes</thetext>
  </long_desc>
  <long_desc>
   <who>jessewilson</who>
   <issue_when>2004-06-02 23:09:50</issue_when>
   <thetext>NEVER AGAIN</thetext>
  </long_desc>
  <activity>
    <user>jessewilson</user>
    <when>2004-04-17 17:48:07</when>
    <field_name>issue_status</field_name>
    <field_desc>Status</field_desc>
    <oldvalue>NEW</oldvalue>
    <newvalue>STARTED</newvalue>
  </activity>
  <activity>
    <user>jessewilson</user>
    <when>2004-05-21 14:34:50</when>
    <field_name>blocked</field_name>
    <field_desc>OtherIssuesDependingOnThis</field_desc>
    <oldvalue></oldvalue>
    <newvalue>41</newvalue>
  </activity>
  <activity>
    <user>jessewilson</user>
    <when>2004-06-02 23:09:50</when>
    <field_name>issue_status</field_name>
    <field_desc>Status</field_desc>
    <oldvalue>STARTED</oldvalue>
    <newvalue>RESOLVED</newvalue>
  </activity>
  <activity>
    <user>jessewilson</user>
    <when>2004-06-02 23:09:50</when>
    <field_name>resolution</field_name>
    <field_desc>Resolution</field_desc>
    <oldvalue></oldvalue>
    <newvalue>FIXED</newvalue>
  </activity>
</issue>
<issue status_code="200" status_message="OK">
  <issue_id>21</issue_id>
  <issue_status>CLOSED</issue_status>
  <priority>P3</priority>
  <resolution>FIXED</resolution>
  <component>glazedlists</component>
  <version>current</version>
  <rep_platform>All</rep_platform>
  <assigned_to>jessewilson</assigned_to>
  <delta_ts>20040415131149</delta_ts>
  <subcomponent>www</subcomponent>
  <reporter>jessewilson</reporter>
  <target_milestone>milestone 1</target_milestone>
  <issue_type>DEFECT</issue_type>
  <creation_ts>2004-03-15 09:20:50</creation_ts>
  <qa_contact>issues@glazedlists</qa_contact>
  <status_whiteboard></status_whiteboard>
  <votes></votes>
  <op_sys>All</op_sys>
  <short_desc>SubList not implemented</short_desc>
  <keywords></keywords>
  <long_desc>
   <who>jessewilson</who>
   <issue_when>2004-03-15 09:20:50</issue_when>
   <thetext>SubList should be implemented. This should be an MutationList on its own, that starts with the initial 
size and accepts add() and remove() from source list.</thetext>
  </long_desc>
  <long_desc>
   <who>jessewilson</who>
   <issue_when>2004-03-16 15:32:26</issue_when>
   <thetext>Implementing SubList as an EventList in its own right will introduce a subtle problem:

The SubList should listen to events from its source list and change itself accordingly. But if the SubList 
is to listen for such events, it must be registered as a ListChangeListener of the source list.

Because the SubList is a ListChangeListener, the source list will always maintain a reference to the 
SubList and the SubList will never go out of scope. Therefore the SubList will never be garbage collected 
and waste memory space.

The work around is to require EventLists to accept two classes of ListChangeListeners - those that 
should be garbage collected once they go out of the scope from the caller and those that should not be 
garbage collected. In effect there should be ListChangeListeners that are stored with weak references 
and those that have regular references.

I would prefer not to change the interface for EventList or ListChangeListener, so it will be tricky to 
determine whether to reference a listener with a weak reference or a regular reference. One solution 
create a proxy class called "WeakReferenceListChangeListenerProxy" that sends changes using a weak 
reference only. This is similar to the SwingThreadProxy already in use in Glazed Lists.</thetext>
  </long_desc>
  <long_desc>
   <who>jessewilson</who>
   <issue_when>2004-03-25 14:37:27</issue_when>
   <thetext>SubList is added and appears to be working.

I still need to perform a test to ensure it is being garbage collected.</thetext>
  </long_desc>
  <long_desc>
   <who>jessewilson</who>
   <issue_when>2004-03-25 19:14:08</issue_when>
   <thetext>Fixed!

The SubList and Iterator now respond to events. Therefore they can be used even if the underlying list 
changes.</thetext>
  </long_desc>
  <long_desc>
   <who>jessewilson</who>
   <issue_when>2004-04-15 13:11:49</issue_when>
   <thetext>This bug has been fixed for two weeks with no problems. I am marking it closed.</thetext>
  </long_desc>
  <activity>
    <user>jessewilson</user>
    <when>2004-03-16 15:32:26</when>
    <field_name>issue_status</field_name>
    <field_desc>Status</field_desc>
    <oldvalue>NEW</oldvalue>
    <newvalue>STARTED</newvalue>
  </activity>
  <activity>
    <user>jessewilson</user>
    <when>2004-03-25 19:14:08</when>
    <field_name>issue_status</field_name>
    <field_desc>Status</field_desc>
    <oldvalue>STARTED</oldvalue>
    <newvalue>RESOLVED</newvalue>
  </activity>
  <activity>
    <user>jessewilson</user>
    <when>2004-03-25 19:14:08</when>
    <field_name>resolution</field_name>
    <field_desc>Resolution</field_desc>
    <oldvalue></oldvalue>
    <newvalue>FIXED</newvalue>
  </activity>
  <activity>
    <user>jessewilson</user>
    <when>2004-04-15 13:11:49</when>
    <field_name>issue_status</field_name>
    <field_desc>Status</field_desc>
    <oldvalue>RESOLVED</oldvalue>
    <newvalue>CLOSED</newvalue>
  </activity>
</issue>
<issue status_code="200" status_message="OK">
  <issue_id>22</issue_id>
  <issue_status>CLOSED</issue_status>
  <priority>P3</priority>
  <resolution>FIXED</resolution>
  <component>glazedlists</component>
  <version>current</version>
  <rep_platform>All</rep_platform>
  <assigned_to>kevinmaltby</assigned_to>
  <delta_ts>20040415131217</delta_ts>
  <subcomponent>www</subcomponent>
  <reporter>jessewilson</reporter>
  <target_milestone>milestone 1</target_milestone>
  <issue_type>DEFECT</issue_type>
  <creation_ts>2004-03-15 11:07:20</creation_ts>
  <qa_contact>issues@glazedlists</qa_contact>
  <status_whiteboard></status_whiteboard>
  <votes></votes>
  <op_sys>All</op_sys>
  <short_desc>CachingList dumps all values whenever the list is changed</short_desc>
  <keywords></keywords>
  <long_desc>
   <who>jessewilson</who>
   <issue_when>2004-03-15 11:07:20</issue_when>
   <thetext>The CachingList will be of growing importance as Glazed Lists are used on the network.

The current implementation of CachingList dumps the entire cache whenever any changes to the list 
occur. The CachingList should only dump values which have been invalidated.</thetext>
  </long_desc>
  <long_desc>
   <who>jessewilson</who>
   <issue_when>2004-03-18 15:30:06</issue_when>
   <thetext>The current CachingList keeps track of what is in its cache by its list index. When the list is modified, 
these list indicies may change and therefore it is necessary to invalidate the entire cache.

In order to fix the CachingList, it will be necessary to change the data structures that support it. This fix 
will be difficult to build!

I am considering allowing this defect to exist in the 1.0 release as it is only a performance problem and 
not a behavioural problem.</thetext>
  </long_desc>
  <long_desc>
   <who>jessewilson</who>
   <issue_when>2004-03-24 17:31:31</issue_when>
   <thetext>I'm assigning this to Kevin Maltby - the best coder I know when caching is concerned. Let's hope my 
flattery and his talent are enough to get this bug fixed!</thetext>
  </long_desc>
  <long_desc>
   <who>jessewilson</who>
   <issue_when>2004-03-31 18:35:57</issue_when>
   <thetext>Kevin has pretty much conquered this one. He's going to CVS commit and close this issue real soon.

I have peer-reviewed his code and it's pretty decent. The peer review session was very helpful and 
hopefully we can get a lot of the Glazed Lists code peer reviewed in the future!</thetext>
  </long_desc>
  <long_desc>
   <who>kevinmaltby</who>
   <issue_when>2004-03-31 23:46:18</issue_when>
   <thetext>The fix is in.  The CachingList now behaves as you would expect.</thetext>
  </long_desc>
  <long_desc>
   <who>jessewilson</who>
   <issue_when>2004-04-15 13:12:17</issue_when>
   <thetext>This bug has been fixed for two weeks with no problems. I am marking it closed.</thetext>
  </long_desc>
  <activity>
    <user>jessewilson</user>
    <when>2004-03-24 17:31:31</when>
    <field_name>assigned_to</field_name>
    <field_desc>Assigned To</field_desc>
    <oldvalue>issues@glazedlists</oldvalue>
    <newvalue>kevinmaltby</newvalue>
  </activity>
  <activity>
    <user>jessewilson</user>
    <when>2004-03-31 18:35:57</when>
    <field_name>issue_status</field_name>
    <field_desc>Status</field_desc>
    <oldvalue>NEW</oldvalue>
    <newvalue>STARTED</newvalue>
  </activity>
  <activity>
    <user>kevinmaltby</user>
    <when>2004-03-31 23:46:18</when>
    <field_name>issue_status</field_name>
    <field_desc>Status</field_desc>
    <oldvalue>STARTED</oldvalue>
    <newvalue>RESOLVED</newvalue>
  </activity>
  <activity>
    <user>kevinmaltby</user>
    <when>2004-03-31 23:46:18</when>
    <field_name>resolution</field_name>
    <field_desc>Resolution</field_desc>
    <oldvalue></oldvalue>
    <newvalue>FIXED</newvalue>
  </activity>
  <activity>
    <user>jessewilson</user>
    <when>2004-04-15 13:12:17</when>
    <field_name>issue_status</field_name>
    <field_desc>Status</field_desc>
    <oldvalue>RESOLVED</oldvalue>
    <newvalue>CLOSED</newvalue>
  </activity>
</issue>
<issue status_code="200" status_message="OK">
  <issue_id>23</issue_id>
  <issue_status>CLOSED</issue_status>
  <priority>P3</priority>
  <resolution>FIXED</resolution>
  <component>glazedlists</component>
  <version>current</version>
  <rep_platform>All</rep_platform>
  <assigned_to>issues@glazedlists</assigned_to>
  <delta_ts>20040408090821</delta_ts>
  <subcomponent>www</subcomponent>
  <reporter>jessewilson</reporter>
  <target_milestone>milestone 1</target_milestone>
  <issue_type>TASK</issue_type>
  <creation_ts>2004-03-15 12:15:04</creation_ts>
  <qa_contact>issues@glazedlists</qa_contact>
  <status_whiteboard></status_whiteboard>
  <votes></votes>
  <op_sys>All</op_sys>
  <short_desc>Add JUnit Support</short_desc>
  <keywords></keywords>
  <long_desc>
   <who>jessewilson</who>
   <issue_when>2004-03-15 12:15:04</issue_when>
   <thetext>As Glazed Lists gets bigger in scope it is becoming very urgent to create a set of unit tests.

There should be a package such as .glazedlists.test that is only compiled if the JUnit libraries are 
detected on the classpath. If they are, then these test files can be built. They can then be tested with a 
"test" target in the project buildfile.

Finally these test classes shall not be included in the library distribution.</thetext>
  </long_desc>
  <long_desc>
   <who>jessewilson</who>
   <issue_when>2004-03-18 09:15:20</issue_when>
   <thetext>I have added the framework for JUnit tests within the Glazed Lists package and build file.

Now all I have to do is write the tests!</thetext>
  </long_desc>
  <long_desc>
   <who>jessewilson</who>
   <issue_when>2004-03-18 14:31:46</issue_when>
   <thetext>I've gone through the code to select which classes are good candidates for unit tests. Unit tests require 
programmatic access so testing Swing stuff will be of marginal value.

package: .glazedlists
AbstractFilterList
BasicEventList
CaseInsensitiveFilterList
SortedList
WritableMutationList

package: .glazedlists.listselectionmodel
SelectionModelEventList

package: .glazedlists.util
BoundedMap
CachingList
EventListIterator
FreezableList
IndexedTree
ReadOnlyList
SparseList

As of March 18, 2004 I have created tests for the CaseInsensitiveFilterList and the SortedList.</thetext>
  </long_desc>
  <long_desc>
   <who>jessewilson</who>
   <issue_when>2004-03-21 10:16:32</issue_when>
   <thetext>The most basic classes now have tests for them.

Some tests are not appropriate for JUnit, for example, concurrency tests.

Regardless, JUnit support is now in the Glazed Lists project. It is possible to add new tests by simply 
creating a class that ends with Test.java. In fact, Glazed Lists now requires that classes ending in 
Test.java must be JUnit tests as such classes are NOT included in the distribution jar.

Anyone interested in getting their hands dirty with Glazed Lists should consider adding more tests to 
our test library!</thetext>
  </long_desc>
  <long_desc>
   <who>jessewilson</who>
   <issue_when>2004-04-08 09:08:21</issue_when>
   <thetext>This bug has been fixed for two weeks with no problems. I am marking it closed.</thetext>
  </long_desc>
  <activity>
    <user>jessewilson</user>
    <when>2004-03-18 09:15:20</when>
    <field_name>issue_status</field_name>
    <field_desc>Status</field_desc>
    <oldvalue>NEW</oldvalue>
    <newvalue>STARTED</newvalue>
  </activity>
  <activity>
    <user>jessewilson</user>
    <when>2004-03-21 10:16:32</when>
    <field_name>issue_status</field_name>
    <field_desc>Status</field_desc>
    <oldvalue>STARTED</oldvalue>
    <newvalue>RESOLVED</newvalue>
  </activity>
  <activity>
    <user>jessewilson</user>
    <when>2004-03-21 10:16:32</when>
    <field_name>resolution</field_name>
    <field_desc>Resolution</field_desc>
    <oldvalue></oldvalue>
    <newvalue>FIXED</newvalue>
  </activity>
  <activity>
    <user>jessewilson</user>
    <when>2004-04-08 09:08:21</when>
    <field_name>issue_status</field_name>
    <field_desc>Status</field_desc>
    <oldvalue>RESOLVED</oldvalue>
    <newvalue>CLOSED</newvalue>
  </activity>
</issue>
<issue status_code="200" status_message="OK">
  <issue_id>24</issue_id>
  <issue_status>NEW</issue_status>
  <priority>P5</priority>
  <resolution></resolution>
  <component>glazedlists</component>
  <version>current</version>
  <rep_platform>All</rep_platform>
  <assigned_to>jessewilson</assigned_to>
  <delta_ts>20040414174648</delta_ts>
  <subcomponent>www</subcomponent>
  <reporter>jessewilson</reporter>
  <target_milestone>milestone 1</target_milestone>
  <issue_type>FEATURE</issue_type>
  <creation_ts>2004-03-18 15:07:01</creation_ts>
  <qa_contact>issues@glazedlists</qa_contact>
  <status_whiteboard></status_whiteboard>
  <votes></votes>
  <op_sys>All</op_sys>
  <short_desc>Add DeltaList for consistency with derivatives of WritableMutationList</short_desc>
  <keywords></keywords>
  <long_desc>
   <who>jessewilson</who>
   <issue_when>2004-03-18 15:07:01</issue_when>
   <thetext>WritableMutationLists allow modifications to be made to the list that may behave differently than 
expected. The solution is to implement a DeltaList, which is a mutation list that provides as-expected 
results when they would not otherwise be possible.

From issue 18:

Daniel Bonin and I were discussing modifyable views and we came up with some observations. When 
using FilterList, SortedList or the like, you can have inconsistent behaviour. For example, the following 
code wil fail.

list x = ...
x.add(0, "Jesse");
assert("Jesse".equals(x.get(0));

This can fail because the inserted value "Jesse" gets filtered out or sorted to a different location.

Our solution: a happy list. The happy list "fakes" success as the method directed. It basically keeps 
track of local changes to make the changes appear consistent. This can be used with GUIs to allow the 
user to verify their modifications without losing the filtering and sorting. 

The happy list will be called "DeltaList" and it will keep track of both the source list and a set of deltas 
that have been performed. When an insert at x occurs, the delta list simulates that the insert occured at 
x, even if the insert was sorted or filtered to a different location.</thetext>
  </long_desc>
  <long_desc>
   <who>jessewilson</who>
   <issue_when>2004-04-14 17:46:48</issue_when>
   <thetext>priority reduced as there is no 'customers' waiting for this feature.</thetext>
  </long_desc>
  <activity>
    <user>jessewilson</user>
    <when>2004-04-14 17:46:48</when>
    <field_name>priority</field_name>
    <field_desc>Priority</field_desc>
    <oldvalue>P3</oldvalue>
    <newvalue>P5</newvalue>
  </activity>
</issue>
<issue status_code="200" status_message="OK">
  <issue_id>25</issue_id>
  <issue_status>STARTED</issue_status>
  <priority>P3</priority>
  <resolution></resolution>
  <component>glazedlists</component>
  <version>current</version>
  <rep_platform>All</rep_platform>
  <assigned_to>issues@glazedlists</assigned_to>
  <delta_ts>20040611154420</delta_ts>
  <subcomponent>www</subcomponent>
  <reporter>jessewilson</reporter>
  <target_milestone>milestone 1</target_milestone>
  <issue_type>DEFECT</issue_type>
  <creation_ts>2004-03-19 14:44:50</creation_ts>
  <qa_contact>issues@glazedlists</qa_contact>
  <status_whiteboard></status_whiteboard>
  <votes></votes>
  <op_sys>All</op_sys>
  <short_desc>CompositeList not thread-safe</short_desc>
  <keywords></keywords>
  <dependson>26</dependson>
  <long_desc>
   <who>jessewilson</who>
   <issue_when>2004-03-19 14:44:50</issue_when>
   <thetext>Glazed Lists' new CompositeList combines multiple event lists into one.

This class is not thread-safe. In particular, it may be possible to cause a deadlock when one thread is 
reading the CompositeList while another thread is writing a list that the CompositeList is composed of.</thetext>
  </long_desc>
  <long_desc>
   <who>jessewilson</who>
   <issue_when>2004-03-21 10:10:05</issue_when>
   <thetext>This bug depends on fixing Issue 26. That issue is for adding beefier concurrency constructs to Glazed 
Lists.</thetext>
  </long_desc>
  <long_desc>
   <who>jessewilson</who>
   <issue_when>2004-06-09 14:33:07</issue_when>
   <thetext>After much thought, I have decided my approach to solving this bug.

Here are the things that all solutions must consider:
1. When one of the source lists change, they call notifyListChanges() while holding the writer lock to 
that source list.
2. When a user needs read access to any list including CompositeList, the user acquires a reader lock 
and performs their access. The list must not change during access.
3. If a thread obtains two locks, it must always obtain the locks in the same order as any other thread 
that may hold those two locks. Otherwise deadlock is possible as threads may compete for each other's 
locks.

My initial idea was as follows:
 - Eliminate the need for locking all source lists for each access
 - When a read is performed, lock the local read lock and the read lock on the source list
 - When a write is performed, lock the local write lock and the write lock of the source list
 - When a source list calls notifyListChanges, use the tryLock() method to attempt to obtain the local 
write lock. If it can be obtained propogate the change. If it cannot, return without propogating the 
change. The thread that currently holds a lock is now responsible for propogating that change.

This strategy has many advantages. It has a constant time to acquire locks, and it takes advantage of 
the listEvent's abilities to be read at a later time. Although this avoids deadlock, the problem this 
strategy is that this does not fulfill requirement 2.

Therefore, I will implement a much simpler and potentially slower strategy:
 - for each lock, present a decorator lock that locks all corresponding locks from the source list
 - obtain the locks in a constant order: by the System.hashCode() value of their source list

This solution looks good! The only problem I have with it is that the System.hashCode() value could 
change for an Object over time if it gets moved within memory. I doubt that this will be a problem but it 
is a good thing to keep an eye on.</thetext>
  </long_desc>
  <long_desc>
   <who>jessewilson</who>
   <issue_when>2004-06-10 08:49:00</issue_when>
   <thetext>My initial implementation is complete, but I still need to add a test class to verify that it is thread safe.</thetext>
  </long_desc>
  <long_desc>
   <who>jessewilson</who>
   <issue_when>2004-06-10 16:27:35</issue_when>
   <thetext>After implementing my proposed solution, I tested it and discovered that it was
failing miserably! The solution has a problem that prevents it from being
acceptable. The notifying thread must have a write lock on the entire list to
prevent changes from being made while the listChanged() method is being handled
by listeners. This is requirement #2 and it is not satisfied by that proposal.
Therefore the proposal is insufficient.

Therefore I propose a new solution, somewhat of a hybrid between the two.
i. Read lock on composite list obtains the read locks of all source lists in
arbitrary order
ii. Write lock on composite list is a special ReadWriteLock called
"PropagateLock" plus the read locks of all source lists.
iii. Upon a change notification in the composite list, that thread tests if the
propagateLock is locked. If it is, it leaves its changes to be propogated by the
thread that currently owns the propogate lock. If that lock is unlocked, the
thread takes the propogate lock and then all read locks in arbitrary order. It
then concatenates its own changes with any changes left while it was collecting
locks. Finally it propagates the concatenated change while holding the propogate
lock, read locks to all source lists, and the original write lock for one source
list.

This combined lock includes the "writer lock" for this list, satisfying
requirement #1. 
The reader lock is a hybrid lock that holds all other read locks, preventing
changes while reading. This satisfies requirement #2.
The reader locks need not be mutex with one another so that solves part of #3.
For writer locks, a thread's 2nd lock is always the propogate lock, and it fails
if that lock is not available immediately, solving another part of #3. Finally,
no thread acquires write locks after owning a first read lock, finishing up the
final area of concern for requirement #3.</thetext>
  </long_desc>
  <long_desc>
   <who>jessewilson</who>
   <issue_when>2004-06-11 11:38:19</issue_when>
   <thetext>Yet again, I have presented a solution that failed in practice. Here is the problem with my most recent 
solution:

Suppose you have two writer threads, A and B that write to source lists Apples and Bananas. There is 
also a reader thread C that reads the composite list of A and B called "FruitSalad".

1. A creates an event in Apples and acquires the write lock to Apples. A = { WL(Apples) }
2. C wants to read the fruit salad and requests a read lock. By the provided implementation, this causes 
C to obtain read locks to each of the two lists Apples and Bananas in arbitrary order. C aquires the read 
lock to Bananas and requests the read lock to Apples, which blocks because A currently holds that lock. 
C = { RL(Bananas), REQUEST(RL(Apples)) }
3. B wants to create an event in Bananas and requests the write lock to Bananas. This blocks because C 
currently holds that lock. B = { REQUEST(WL(Bananas)) }
4. A forwards its event to FruitSalad, regarding its change to Apples. A attempts to acquire the read 
locks to all lists in FruitSalad in order to forward this event. When attempting to acquire the read lock to 
Bananas, this request is blocked because there is a waiting request for the write lock to Bananas by B. 
Therefore A = { WL(Apples), REQUEST(RL(Bananas)) }

As you can see, all of the lists are awaiting requests held by each other and we have a deadlock. This 
sucks! I do not think it is appropriate to change the preferences on the lock orders because doing so 
may severely limit the original concurrency goals of Glazed Lists.

For now, I will continue to ponder a better solution. </thetext>
  </long_desc>
  <long_desc>
   <who>jessewilson</who>
   <issue_when>2004-06-11 15:44:20</issue_when>
   <thetext>Created an attachment (id=2)
My request for help on Usenet
</thetext>
  </long_desc>
  <attachment encoding="Base64">
    <mimetype>text/html</mimetype>
    <attachid>2</attachid>
    <date>2004-06-11 15:44:20</date>
    <desc>My request for help on Usenet</desc>
    <ispatch></ispatch>
    <filename>askforhelp.html</filename>
    <submitter_id>3</submitter_id>
    <submitting_username>jessewilson</submitting_username>
    <data></data>
  <attachment_iz_url>https://glazedlists.dev.java.net/nonav/issues/showattachment.cgi/2/askforhelp.html</attachment_iz_url>
  </attachment>
  <activity>
    <user>jessewilson</user>
    <when>2004-03-19 14:44:50</when>
    <field_name>dependson</field_name>
    <field_desc>IssuesThisDependsOn</field_desc>
    <oldvalue></oldvalue>
    <newvalue>26</newvalue>
  </activity>
  <activity>
    <user>jessewilson</user>
    <when>2004-06-09 14:33:07</when>
    <field_name>issue_status</field_name>
    <field_desc>Status</field_desc>
    <oldvalue>NEW</oldvalue>
    <newvalue>STARTED</newvalue>
  </activity>
  <activity>
    <user>jessewilson</user>
    <when>2004-06-11 15:44:20</when>
    <field_name>attachments.thedata</field_name>
    <field_desc>Attachment Data</field_desc>
    <oldvalue></oldvalue>
    <newvalue>Created an attachment (id=2)
My request for help on Usenet
</newvalue>
  </activity>
</issue>
<issue status_code="200" status_message="OK">
  <issue_id>26</issue_id>
  <issue_status>CLOSED</issue_status>
  <priority>P3</priority>
  <resolution>FIXED</resolution>
  <component>glazedlists</component>
  <version>current</version>
  <rep_platform>All</rep_platform>
  <assigned_to>jessewilson</assigned_to>
  <delta_ts>20040609143533</delta_ts>
  <subcomponent>www</subcomponent>
  <reporter>jessewilson</reporter>
  <target_milestone>milestone 1</target_milestone>
  <issue_type>DEFECT</issue_type>
  <creation_ts>2004-03-21 10:09:09</creation_ts>
  <qa_contact>issues@glazedlists</qa_contact>
  <status_whiteboard></status_whiteboard>
  <votes></votes>
  <op_sys>All</op_sys>
  <short_desc>Replace global lock with reader/writer locks</short_desc>
  <keywords></keywords>
  <blocks>25</blocks>
  <blocks>41</blocks>
  <long_desc>
   <who>jessewilson</who>
   <issue_when>2004-03-21 10:09:09</issue_when>
   <thetext>The current Glazed Lists uses global locks for all reads and writes. It would higher performance to use a 
reader/writer lock instead.

The reader/writer lock could be either requested via eventList.getLock().aquireRead() or via 
eventList.aquireReadLock(). I think I prefer using getLock(), which returns an object implementing a 
ReaderWriterLock interface. That way I can easily swap out the lock implementation.</thetext>
  </long_desc>
  <long_desc>
   <who>jessewilson</who>
   <issue_when>2004-05-21 14:14:46</issue_when>
   <thetext>We've swapped the global synchronized on root list to global reader writer locks.

We can now replace that with local locks.</thetext>
  </long_desc>
  <long_desc>
   <who>jessewilson</who>
   <issue_when>2004-05-21 14:36:17</issue_when>
   <thetext>I am marking this problem as "fixed" and creating a new issue which covers concurrent mutationlist 
modifications.</thetext>
  </long_desc>
  <long_desc>
   <who>jessewilson</who>
   <issue_when>2004-06-09 14:35:33</issue_when>
   <thetext>This bug has been fixed for two weeks with no problems. I am marking it closed.</thetext>
  </long_desc>
  <activity>
    <user>jessewilson</user>
    <when>2004-03-19 14:44:50</when>
    <field_name>blocked</field_name>
    <field_desc>OtherIssuesDependingOnThis</field_desc>
    <oldvalue></oldvalue>
    <newvalue>25</newvalue>
  </activity>
  <activity>
    <user>jessewilson</user>
    <when>2004-05-21 14:14:46</when>
    <field_name>issue_status</field_name>
    <field_desc>Status</field_desc>
    <oldvalue>NEW</oldvalue>
    <newvalue>STARTED</newvalue>
  </activity>
  <activity>
    <user>jessewilson</user>
    <when>2004-05-21 14:34:50</when>
    <field_name>blocked</field_name>
    <field_desc>OtherIssuesDependingOnThis</field_desc>
    <oldvalue>25</oldvalue>
    <newvalue>25,41</newvalue>
  </activity>
  <activity>
    <user>jessewilson</user>
    <when>2004-05-21 14:36:17</when>
    <field_name>issue_status</field_name>
    <field_desc>Status</field_desc>
    <oldvalue>STARTED</oldvalue>
    <newvalue>RESOLVED</newvalue>
  </activity>
  <activity>
    <user>jessewilson</user>
    <when>2004-05-21 14:36:17</when>
    <field_name>resolution</field_name>
    <field_desc>Resolution</field_desc>
    <oldvalue></oldvalue>
    <newvalue>FIXED</newvalue>
  </activity>
  <activity>
    <user>jessewilson</user>
    <when>2004-06-09 14:35:33</when>
    <field_name>issue_status</field_name>
    <field_desc>Status</field_desc>
    <oldvalue>RESOLVED</oldvalue>
    <newvalue>CLOSED</newvalue>
  </activity>
</issue>
<issue status_code="200" status_message="OK">
  <issue_id>27</issue_id>
  <issue_status>CLOSED</issue_status>
  <priority>P3</priority>
  <resolution>FIXED</resolution>
  <component>glazedlists</component>
  <version>current</version>
  <rep_platform>All</rep_platform>
  <assigned_to>kevinmaltby</assigned_to>
  <delta_ts>20040521142001</delta_ts>
  <subcomponent>www</subcomponent>
  <reporter>jessewilson</reporter>
  <target_milestone>milestone 1</target_milestone>
  <issue_type>FEATURE</issue_type>
  <creation_ts>2004-03-22 14:55:29</creation_ts>
  <qa_contact>issues@glazedlists</qa_contact>
  <status_whiteboard></status_whiteboard>
  <votes></votes>
  <op_sys>All</op_sys>
  <short_desc>UniqueList not implemented</short_desc>
  <keywords></keywords>
  <dependson>40</dependson>
  <blocks>37</blocks>
  <long_desc>
   <who>jessewilson</who>
   <issue_when>2004-03-22 14:55:29</issue_when>
   <thetext>Glazed Lists needs a UniqueList that can take two lists and show only the unique values.</thetext>
  </long_desc>
  <long_desc>
   <who>jessewilson</who>
   <issue_when>2004-04-06 14:51:25</issue_when>
   <thetext>Kevin Maltby has got a working implementation! What a stallion!</thetext>
  </long_desc>
  <long_desc>
   <who>kevinmaltby</who>
   <issue_when>2004-04-07 22:20:22</issue_when>
   <thetext>UniqueLists are now implemented to provide a unique view of a given list.</thetext>
  </long_desc>
  <long_desc>
   <who>kevinmaltby</who>
   <issue_when>2004-04-11 16:46:07</issue_when>
   <thetext>Jesse Wilson broke it with the addition of the testUpdateDeleteCollide test 
case.

The result of this test was the following Exception...

    [junit] Testcase: testUpdateDeleteCollide(com.odellengineeringltd.glazedlist
s.util.UniqueListTest): Caused an ERROR
    [junit] cannot get from tree of size 1 at 1
    [junit] java.lang.IndexOutOfBoundsException: cannot get from tree of size 1
at 1
    [junit]     at com.odellengineeringltd.glazedlists.util.IndexedTreeNode.getN
odeWithIndex(IndexedTreeNode.java:81)
    [junit]     at com.odellengineeringltd.glazedlists.util.IndexedTree.getNode(
IndexedTree.java:64)
    [junit]     at com.odellengineeringltd.glazedlists.SortedList.get(SortedList
.java:239)
    [junit]     at com.odellengineeringltd.glazedlists.util.UniqueList.get(Uniqu
eList.java:167)
    [junit]     at com.odellengineeringltd.glazedlists.util.UniqueList.processIn
sertEvent(UniqueList.java:259)
    [junit]     at com.odellengineeringltd.glazedlists.util.UniqueList.notifyLis
tChanges(UniqueList.java:209)
    [junit]     at com.odellengineeringltd.glazedlists.event.ListChangeSequence.
commitAtomicChange(ListChangeSequence.java:134)
    [junit]     at com.odellengineeringltd.glazedlists.SortedList.notifyListChan
ges(SortedList.java:146)
    [junit]     at com.odellengineeringltd.glazedlists.event.ListChangeSequence.
commitAtomicChange(ListChangeSequence.java:134)
    [junit]     at com.odellengineeringltd.glazedlists.AbstractFilterList.handle
FilterChanged(AbstractFilterList.java:187)
    [junit]     at com.odellengineeringltd.glazedlists.util.UniqueListTest$IntAr
rayFilterList.setFilter(UniqueListTest.java:526)
    [junit]     at com.odellengineeringltd.glazedlists.util.UniqueListTest.testU
pdateDeleteCollide(UniqueListTest.java:542)</thetext>
  </long_desc>
  <long_desc>
   <who>jessewilson</who>
   <issue_when>2004-04-14 18:51:34</issue_when>
   <thetext>This is broken because some naive programmer guy didn't do a very good job at implementing 
SortedList. </thetext>
  </long_desc>
  <long_desc>
   <who>jessewilson</who>
   <issue_when>2004-04-15 13:02:36</issue_when>
   <thetext>This bug has been fixed as a consequence of bug 37 being fixed.

I performed the Unit Tests and all worked perfectly, for 1000 elements filtered 10 times.</thetext>
  </long_desc>
  <long_desc>
   <who>jessewilson</who>
   <issue_when>2004-05-21 14:20:01</issue_when>
   <thetext>This bug has been fixed for two weeks with no problems. I am marking it closed.</thetext>
  </long_desc>
  <activity>
    <user>jessewilson</user>
    <when>2004-04-06 14:51:25</when>
    <field_name>assigned_to</field_name>
    <field_desc>Assigned To</field_desc>
    <oldvalue>issues@glazedlists</oldvalue>
    <newvalue>kevinmaltby</newvalue>
  </activity>
  <activity>
    <user>kevinmaltby</user>
    <when>2004-04-07 22:20:22</when>
    <field_name>issue_status</field_name>
    <field_desc>Status</field_desc>
    <oldvalue>NEW</oldvalue>
    <newvalue>RESOLVED</newvalue>
  </activity>
  <activity>
    <user>kevinmaltby</user>
    <when>2004-04-07 22:20:22</when>
    <field_name>resolution</field_name>
    <field_desc>Resolution</field_desc>
    <oldvalue></oldvalue>
    <newvalue>FIXED</newvalue>
  </activity>
  <activity>
    <user>kevinmaltby</user>
    <when>2004-04-11 16:46:07</when>
    <field_name>issue_status</field_name>
    <field_desc>Status</field_desc>
    <oldvalue>RESOLVED</oldvalue>
    <newvalue>REOPENED</newvalue>
  </activity>
  <activity>
    <user>kevinmaltby</user>
    <when>2004-04-11 16:46:07</when>
    <field_name>resolution</field_name>
    <field_desc>Resolution</field_desc>
    <oldvalue>FIXED</oldvalue>
    <newvalue></newvalue>
  </activity>
  <activity>
    <user>jessewilson</user>
    <when>2004-04-11 16:46:07</when>
    <field_name>dependson</field_name>
    <field_desc>IssuesThisDependsOn</field_desc>
    <oldvalue></oldvalue>
    <newvalue>40</newvalue>
  </activity>
  <activity>
    <user>jessewilson</user>
    <when>2004-04-08 08:56:57</when>
    <field_name>blocked</field_name>
    <field_desc>OtherIssuesDependingOnThis</field_desc>
    <oldvalue></oldvalue>
    <newvalue>37</newvalue>
  </activity>
  <activity>
    <user>jessewilson</user>
    <when>2004-04-15 13:02:36</when>
    <field_name>issue_status</field_name>
    <field_desc>Status</field_desc>
    <oldvalue>REOPENED</oldvalue>
    <newvalue>RESOLVED</newvalue>
  </activity>
  <activity>
    <user>jessewilson</user>
    <when>2004-04-15 13:02:36</when>
    <field_name>resolution</field_name>
    <field_desc>Resolution</field_desc>
    <oldvalue></oldvalue>
    <newvalue>FIXED</newvalue>
  </activity>
  <activity>
    <user>jessewilson</user>
    <when>2004-05-21 14:20:01</when>
    <field_name>issue_status</field_name>
    <field_desc>Status</field_desc>
    <oldvalue>RESOLVED</oldvalue>
    <newvalue>CLOSED</newvalue>
  </activity>
</issue>
<issue status_code="200" status_message="OK">
  <issue_id>28</issue_id>
  <issue_status>CLOSED</issue_status>
  <priority>P1</priority>
  <resolution>FIXED</resolution>
  <component>glazedlists</component>
  <version>current</version>
  <rep_platform>All</rep_platform>
  <assigned_to>issues@glazedlists</assigned_to>
  <delta_ts>20040521141924</delta_ts>
  <subcomponent>www</subcomponent>
  <reporter>jessewilson</reporter>
  <target_milestone>milestone 1</target_milestone>
  <issue_type>DEFECT</issue_type>
  <creation_ts>2004-03-22 16:52:20</creation_ts>
  <qa_contact>issues@glazedlists</qa_contact>
  <status_whiteboard></status_whiteboard>
  <votes></votes>
  <op_sys>All</op_sys>
  <short_desc>Lists may fail if the change event indicies are out of order</short_desc>
  <keywords></keywords>
  <long_desc>
   <who>jessewilson</who>
   <issue_when>2004-03-22 16:52:20</issue_when>
   <thetext>Lists that evaluate the values such as SortedList and FilteredList may break if the change event has 
indicies that arrive out of order.

There should be a test for this added to the unit tests and a fix should be made if the problem is 
legitimate.</thetext>
  </long_desc>
  <long_desc>
   <who>jessewilson</who>
   <issue_when>2004-03-23 18:29:42</issue_when>
   <thetext>I have created a JUnit test that confirms the presense of this bug. That test has been added to CVS.

The solution as I see it is to add a method in the ListChangeSequence that is called from 
commitAtomicChanges(). Such a method would examine the list change events and re-order them into 
order of increasing index.

The reordering could potentially also merge adjacent list change blocks but this is not totally necessary.</thetext>
  </long_desc>
  <long_desc>
   <who>jessewilson</who>
   <issue_when>2004-03-24 16:59:48</issue_when>
   <thetext>The ListChangeSequence now bubble-sorts change blocks when the change is commited.

BubbleSort was used because it only swaps adjacent entries. When two change blocks are swapped, 
their indicies must be modified relative to one another. Therefore bubble sort is the simplest sort to 
implement.</thetext>
  </long_desc>
  <long_desc>
   <who>jessewilson</who>
   <issue_when>2004-03-25 13:22:15</issue_when>
   <thetext>This bug appears to remain broken:

    [junit] Testcase: testIndexOutOfOrder(com.odellengineeringltd.glazedlists.test.IndexOrderTest):     
FAILED
    [junit] expected:&lt;[[I@c05d3b, [I@28f6ee, [I@6bade9, [I@66afb3, [I@9945ce, [I@b5dac4, [I@2d96f2, 
[I@110003, [I@17e4ca, [I@adb1d4, [I@75d6ab, [I@60a26f, [I@484a05, [I@f39b3a, [I@542a75, 
[I@af993e, [I@75e4fc, [I@c62c8, [I@2940b3, [I@56b6b9, [I@f66cff, [I@6de49c, [I@bbf1ca, [I@ff0dde, 
[I@e78fc6, [I@901437, [I@1f6226, [I@64ea66, [I@58f9d3, [I@79a2e7, [I@b60280, [I@5e55ab, 
[I@4a55f2, [I@5093f1, [I@20bf2c, [I@e6f7d2, [I@9836ed, [I@3e0ebb, [I@39443f, [I@afae45, [I@da4b71, 
[I@8f1d7e, [I@d9660d, [I@bb0d0d, [I@55e55f, [I@45c859, [I@64883c, [I@2c1e6b, [I@811c88, 
[I@785d65, [I@3bc257, [I@53f67e, [I@5bdc50, [I@dd3812, [I@8c436b, [I@9e5c73, [I@c791b9, 
[I@3020ad, [I@b15692, [I@aa9f99, [I@d42d08, [I@d86fd3, [I@958bb8, [I@7f4ec, [I@60e128, 
[I@5e1077, [I@8b3364, [I@db05b2, [I@530cf2, [I@76fba0, [I@81ed9e, [I@175422, [I@949f69, 
[I@6dadf9, [I@b8d6f7, [I@290fbc, [I@c80b01, [I@4aa0ce, [I@833eca, [I@8f5824, [I@e3cd51, [I@bc8e1e, 
[I@1671b2, [I@82764b, [I@2452e8, [I@bf3d87, [I@60991f, [I@e4f7c2, [I@45f0e3, [I@c9d92c, [I@d0fafc, 
[I@dc6b5, [I@70bea5, [I@f47396, [I@d0af9b, [I@b8f8eb, [I@de17f4, [I@f6ba0f, [I@313906, [I@96cf11, 
[I@f47bf5, [I@f6438d, [I@cd0888]&gt; but was:&lt;[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 
18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 
44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 
70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 
96, 97, 98, 99, 100, 101]&gt;
    [junit] junit.framework.AssertionFailedError: expected:&lt;[[I@c05d3b, [I@28f6ee, [I@6bade9, 
[I@66afb3, [I@9945ce, [I@b5dac4, [I@2d96f2, [I@110003, [I@17e4ca, [I@adb1d4, [I@75d6ab, 
[I@60a26f, [I@484a05, [I@f39b3a, [I@542a75, [I@af993e, [I@75e4fc, [I@c62c8, [I@2940b3, [I@56b6b9, 
[I@f66cff, [I@6de49c, [I@bbf1ca, [I@ff0dde, [I@e78fc6, [I@901437, [I@1f6226, [I@64ea66, [I@58f9d3, 
[I@79a2e7, [I@b60280, [I@5e55ab, [I@4a55f2, [I@5093f1, [I@20bf2c, [I@e6f7d2, [I@9836ed, 
[I@3e0ebb, [I@39443f, [I@afae45, [I@da4b71, [I@8f1d7e, [I@d9660d, [I@bb0d0d, [I@55e55f, 
[I@45c859, [I@64883c, [I@2c1e6b, [I@811c88, [I@785d65, [I@3bc257, [I@53f67e, [I@5bdc50, 
[I@dd3812, [I@8c436b, [I@9e5c73, [I@c791b9, [I@3020ad, [I@b15692, [I@aa9f99, [I@d42d08, 
[I@d86fd3, [I@958bb8, [I@7f4ec, [I@60e128, [I@5e1077, [I@8b3364, [I@db05b2, [I@530cf2, [I@76fba0, 
[I@81ed9e, [I@175422, [I@949f69, [I@6dadf9, [I@b8d6f7, [I@290fbc, [I@c80b01, [I@4aa0ce, [I@833eca, 
[I@8f5824, [I@e3cd51, [I@bc8e1e, [I@1671b2, [I@82764b, [I@2452e8, [I@bf3d87, [I@60991f, 
[I@e4f7c2, [I@45f0e3, [I@c9d92c, [I@d0fafc, [I@dc6b5, [I@70bea5, [I@f47396, [I@d0af9b, [I@b8f8eb, 
[I@de17f4, [I@f6ba0f, [I@313906, [I@96cf11, [I@f47bf5, [I@f6438d, [I@cd0888]&gt; but was:&lt;[0, 1, 2, 3, 
4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 
32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 
58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 
84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101]&gt;
    [junit]     at 
com.odellengineeringltd.glazedlists.test.IndexOrderTest.testIndexOutOfOrder(IndexOrderTest.java:85)
    [junit]     at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
    [junit]     at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
    [junit]     at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:
25)
</thetext>
  </long_desc>
  <long_desc>
   <who>kevinmaltby</who>
   <issue_when>2004-04-03 14:10:09</issue_when>
   <thetext>The current ordering of events appears to be inverted and thus events appear in 
decreasing order.</thetext>
  </long_desc>
  <long_desc>
   <who>jessewilson</who>
   <issue_when>2004-04-05 22:58:38</issue_when>
   <thetext>Fixed! Again! This bug has haunted me all day. 

The solution sorts and combines properly, but not necessarily too efficiently. If this proves to be a 
problem, I'll send the optimization police onto it!

Here's an example of the (poor) runtime. Changes are measured in loop executions.
    [junit] Changed! blocks before: 142, after: 142, changes: 141
    [junit] Changed! blocks before: 204, after: 1, changes: 405
    [junit] Changed! blocks before: 203, after: 88, changes: 9890
    [junit] Changed! blocks before: 306, after: 253, changes: 647
    [junit] Changed! blocks before: 541, after: 40, changes: 5257
    [junit] Changed! blocks before: 514, after: 73, changes: 27433
    [junit] Changed! blocks before: 212, after: 158, changes: 439
    [junit] Changed! blocks before: 626, after: 9, changes: 46633
    [junit] Changed! blocks before: 548, after: 67, changes: 22004
    [junit] Changed! blocks before: 141, after: 141, changes: 140
    [junit] Changed! blocks before: 411, after: 91, changes: 20767
    [junit] Changed! blocks before: 119, after: 119, changes: 118
    [junit] Changed! blocks before: 490, after: 2, changes: 32108
    [junit] Changed! blocks before: 460, after: 81, changes: 24387
    [junit] Changed! blocks before: 121, after: 121, changes: 120
    [junit] Changed! blocks before: 551, after: 81, changes: 24285
    [junit] Changed! blocks before: 219, after: 176, changes: 447
    [junit] Changed! blocks before: 623, after: 68, changes: 53634
    [junit] Changed! blocks before: 572, after: 23, changes: 23838
    [junit] Changed! blocks before: 34, after: 34, changes: 33
    [junit] Changed! blocks before: 41, after: 29, changes: 919
    [junit] Changed! blocks before: 55, after: 55, changes: 54
    [junit] Changed! blocks before: 77, after: 50, changes: 2964
    [junit] Changed! blocks before: 65, after: 1, changes: 127
    [junit] Changed! blocks before: 46, after: 46, changes: 45
</thetext>
  </long_desc>
  <long_desc>
   <who>jessewilson</who>
   <issue_when>2004-05-21 14:19:24</issue_when>
   <thetext>This bug has been fixed for two weeks with no problems. I am marking it closed.</thetext>
  </long_desc>
  <activity>
    <user>jessewilson</user>
    <when>2004-03-23 18:29:42</when>
    <field_name>issue_status</field_name>
    <field_desc>Status</field_desc>
    <oldvalue>NEW</oldvalue>
    <newvalue>STARTED</newvalue>
  </activity>
  <activity>
    <user>jessewilson</user>
    <when>2004-03-24 16:59:48</when>
    <field_name>issue_status</field_name>
    <field_desc>Status</field_desc>
    <oldvalue>STARTED</oldvalue>
    <newvalue>RESOLVED</newvalue>
  </activity>
  <activity>
    <user>jessewilson</user>
    <when>2004-03-24 16:59:48</when>
    <field_name>resolution</field_name>
    <field_desc>Resolution</field_desc>
    <oldvalue></oldvalue>
    <newvalue>FIXED</newvalue>
  </activity>
  <activity>
    <user>jessewilson</user>
    <when>2004-03-25 13:22:15</when>
    <field_name>issue_status</field_name>
    <field_desc>Status</field_desc>
    <oldvalue>RESOLVED</oldvalue>
    <newvalue>REOPENED</newvalue>
  </activity>
  <activity>
    <user>jessewilson</user>
    <when>2004-03-25 13:22:15</when>
    <field_name>resolution</field_name>
    <field_desc>Resolution</field_desc>
    <oldvalue>FIXED</oldvalue>
    <newvalue></newvalue>
  </activity>
  <activity>
    <user>jessewilson</user>
    <when>2004-04-05 22:58:38</when>
    <field_name>issue_status</field_name>
    <field_desc>Status</field_desc>
    <oldvalue>REOPENED</oldvalue>
    <newvalue>RESOLVED</newvalue>
  </activity>
  <activity>
    <user>jessewilson</user>
    <when>2004-04-05 22:58:38</when>
    <field_name>resolution</field_name>
    <field_desc>Resolution</field_desc>
    <oldvalue></oldvalue>
    <newvalue>FIXED</newvalue>
  </activity>
  <activity>
    <user>jessewilson</user>
    <when>2004-05-21 14:19:24</when>
    <field_name>issue_status</field_name>
    <field_desc>Status</field_desc>
    <oldvalue>RESOLVED</oldvalue>
    <newvalue>CLOSED</newvalue>
  </activity>
</issue>
<issue status_code="200" status_message="OK">
  <issue_id>29</issue_id>
  <issue_status>CLOSED</issue_status>
  <priority>P4</priority>
  <resolution>FIXED</resolution>
  <component>glazedlists</component>
  <version>current</version>
  <rep_platform>All</rep_platform>
  <assigned_to>jessewilson</assigned_to>
  <delta_ts>20040521142023</delta_ts>
  <subcomponent>www</subcomponent>
  <reporter>jessewilson</reporter>
  <target_milestone>milestone 1</target_milestone>
  <issue_type>DEFECT</issue_type>
  <creation_ts>2004-03-25 12:39:34</creation_ts>
  <qa_contact>issues@glazedlists</qa_contact>
  <status_whiteboard></status_whiteboard>
  <votes></votes>
  <op_sys>All</op_sys>
  <short_desc>ToString on BasicEventList, MutationList no good</short_desc>
  <keywords></keywords>
  <blocks>37</blocks>
  <long_desc>
   <who>jessewilson</who>
   <issue_when>2004-03-25 12:39:34</issue_when>
   <thetext>The toString value on Java Lists is like "[lemon, orange, apple, banana]"
but on Glazed Lists it is like "com.odellengineeringltd.glazedlists.BasicEventList@f4d448ce"</thetext>
  </long_desc>
  <long_desc>
   <who>kevinmaltby</who>
   <issue_when>2004-04-09 14:06:57</issue_when>
   <thetext>The toString value on Glazed Lists is the same as the toString value on Java 
Lists now.</thetext>
  </long_desc>
  <long_desc>
   <who>jessewilson</who>
   <issue_when>2004-05-21 14:20:23</issue_when>
   <thetext>This bug has been fixed for two weeks with no problems. I am marking it closed.</thetext>
  </long_desc>
  <activity>
    <user>jessewilson</user>
    <when>2004-04-08 08:56:02</when>
    <field_name>blocked</field_name>
    <field_desc>OtherIssuesDependingOnThis</field_desc>
    <oldvalue></oldvalue>
    <newvalue>37</newvalue>
  </activity>
  <activity>
    <user>kevinmaltby</user>
    <when>2004-04-09 14:06:57</when>
    <field_name>issue_status</field_name>
    <field_desc>Status</field_desc>
    <oldvalue>NEW</oldvalue>
    <newvalue>RESOLVED</newvalue>
  </activity>
  <activity>
    <user>kevinmaltby</user>
    <when>2004-04-09 14:06:57</when>
    <field_name>resolution</field_name>
    <field_desc>Resolution</field_desc>
    <oldvalue></oldvalue>
    <newvalue>FIXED</newvalue>
  </activity>
  <activity>
    <user>jessewilson</user>
    <when>2004-05-21 14:20:23</when>
    <field_name>issue_status</field_name>
    <field_desc>Status</field_desc>
    <oldvalue>RESOLVED</oldvalue>
    <newvalue>CLOSED</newvalue>
  </activity>
</issue>
<issue status_code="200" status_message="OK">
  <issue_id>30</issue_id>
  <issue_status>CLOSED</issue_status>
  <priority>P4</priority>
  <resolution>FIXED</resolution>
  <component>glazedlists</component>
  <version>current</version>
  <rep_platform>All</rep_platform>
  <assigned_to>issues@glazedlists</assigned_to>
  <delta_ts>20040521142040</delta_ts>
  <subcomponent>www</subcomponent>
  <reporter>jessewilson</reporter>
  <target_milestone>milestone 1</target_milestone>
  <issue_type>TASK</issue_type>
  <creation_ts>2004-03-26 08:05:12</creation_ts>
  <qa_contact>issues@glazedlists</qa_contact>
  <status_whiteboard></status_whiteboard>
  <votes></votes>
  <op_sys>All</op_sys>
  <short_desc>Verify ListTable changeSizeRepaintAllThreshhold works</short_desc>
  <keywords></keywords>
  <blocks>37</blocks>
  <long_desc>
   <who>jessewilson</who>
   <issue_when>2004-03-26 08:05:12</issue_when>
   <thetext>Some users have had problems with the behaviour of Glazed Lists when the 
changeSizeRepaintAllThreshhold is low.

Verify that the behaviour is:
 - correct
 - faster than using single changes</thetext>
  </long_desc>
  <long_desc>
   <who>jessewilson</who>
   <issue_when>2004-04-11 13:32:50</issue_when>
   <thetext>I've done some research and learned a lot about the behaviour of JTable.

When you give JTable a large set of small changes, it has different behaviour depending on what its 
renderer is doing. If the table rows all have a uniform height, then the JTable is very fast at handling 
such a set of changes. If the table rows have nonuniform height, however, the JTable is very slow.

Therefore I am going to make a few small changes:
 - I am going to further document the changeSizeRepaintAllThreshhold and its relationship with the 
table speed in both the ListTable class and in the performance section of the tutorial
 - I am going to change the default value of changeSizeRepaintAllThreshhold to 250, and add proper 
getter and setter values. The table performance was intolerable with variable row sizes when there were 
mroe than 250 changes, but may be acceptable below that.

Note that the changeSizeRepaintAllThreshhold is an unwanted hack to work around the poor behaviour 
of JTable in such situations. It has major problems because it forces the table to lose its selection and 
its scrolling.</thetext>
  </long_desc>
  <long_desc>
   <who>jessewilson</who>
   <issue_when>2004-04-11 14:32:29</issue_when>
   <thetext>I have changed the behaviour of repaintAllThreshhold to default to Integer.MAX_VALUE. Therefore new 
repaintAllThreshhold must be set manually to be enabled. This is good because the whole thing is kind 
of an ugly hack to get around the poor behaviour of the JTable's ability to track row height. 

I believe the whole problem stems from a poor implementation of SizeSequence in the JVM. I think a 
tree-based structure similar to the one used for SparseList may be more appropriate.</thetext>
  </long_desc>
  <long_desc>
   <who>jessewilson</who>
   <issue_when>2004-05-21 14:20:40</issue_when>
   <thetext>This bug has been fixed for two weeks with no problems. I am marking it closed.</thetext>
  </long_desc>
  <activity>
    <user>jessewilson</user>
    <when>2004-04-08 08:56:02</when>
    <field_name>blocked</field_name>
    <field_desc>OtherIssuesDependingOnThis</field_desc>
    <oldvalue></oldvalue>
    <newvalue>37</newvalue>
  </activity>
  <activity>
    <user>jessewilson</user>
    <when>2004-04-11 13:32:50</when>
    <field_name>issue_status</field_name>
    <field_desc>Status</field_desc>
    <oldvalue>NEW</oldvalue>
    <newvalue>STARTED</newvalue>
  </activity>
  <activity>
    <user>jessewilson</user>
    <when>2004-04-11 14:32:29</when>
    <field_name>issue_status</field_name>
    <field_desc>Status</field_desc>
    <oldvalue>STARTED</oldvalue>
    <newvalue>RESOLVED</newvalue>
  </activity>
  <activity>
    <user>jessewilson</user>
    <when>2004-04-11 14:32:29</when>
    <field_name>resolution</field_name>
    <field_desc>Resolution</field_desc>
    <oldvalue></oldvalue>
    <newvalue>FIXED</newvalue>
  </activity>
  <activity>
    <user>jessewilson</user>
    <when>2004-05-21 14:20:40</when>
    <field_name>issue_status</field_name>
    <field_desc>Status</field_desc>
    <oldvalue>RESOLVED</oldvalue>
    <newvalue>CLOSED</newvalue>
  </activity>
</issue>
<issue status_code="200" status_message="OK">
  <issue_id>31</issue_id>
  <issue_status>CLOSED</issue_status>
  <priority>P2</priority>
  <resolution>FIXED</resolution>
  <component>glazedlists</component>
  <version>current</version>
  <rep_platform>All</rep_platform>
  <assigned_to>issues@glazedlists</assigned_to>
  <delta_ts>20040521141941</delta_ts>
  <subcomponent>www</subcomponent>
  <reporter>jessewilson</reporter>
  <target_milestone>milestone 1</target_milestone>
  <issue_type>ENHANCEMENT</issue_type>
  <creation_ts>2004-03-26 09:04:45</creation_ts>
  <qa_contact>issues@glazedlists</qa_contact>
  <status_whiteboard></status_whiteboard>
  <votes></votes>
  <op_sys>All</op_sys>
  <short_desc>More powerful TableComparatorSelector</short_desc>
  <keywords></keywords>
  <long_desc>
   <who>jessewilson</who>
   <issue_when>2004-03-26 09:04:45</issue_when>
   <thetext>Glazed Lists' TableComparatorSelector does not:
 - have chevrons or arrows to indicate sort order
 - allow sorting by multiple columns simultaneously

These should be implemented by "beefing-up" TableComparatorSelector.</thetext>
  </long_desc>
  <long_desc>
   <who>jessewilson</who>
   <issue_when>2004-03-30 18:29:15</issue_when>
   <thetext>I've moved this from priority 4 to priority 2 due to demand!

I also got some additional info from the users mailing list.

Source for a tool that does table header stuff well:
http://www.fawcette.com/javapro/2002_08/magazine/columns/visualcomponents/

Also - the table should support raw-order sort.</thetext>
  </long_desc>
  <long_desc>
   <who>jessewilson</who>
   <issue_when>2004-04-02 17:22:50</issue_when>
   <thetext>I have started preliminary work on this.

I have yet to do the header arrows and multiple-column sort, but the new TableComparatorSelector is 
already much, much better.</thetext>
  </long_desc>
  <long_desc>
   <who>jessewilson</who>
   <issue_when>2004-04-03 20:18:55</issue_when>
   <thetext>I've added support for multiple column sort, and arrow icons.

Header/table sorting is now a FIRST CLASS feature in Glazed Lists.

All that's left is support for raw sort order. I will enter a new bug for that as the support should be done 
in SortedList.</thetext>
  </long_desc>
  <long_desc>
   <who>jessewilson</who>
   <issue_when>2004-05-21 14:19:41</issue_when>
   <thetext>This bug has been fixed for two weeks with no problems. I am marking it closed.</thetext>
  </long_desc>
  <activity>
    <user>jessewilson</user>
    <when>2004-03-30 18:29:15</when>
    <field_name>issue_status</field_name>
    <field_desc>Status</field_desc>
    <oldvalue>NEW</oldvalue>
    <newvalue>STARTED</newvalue>
  </activity>
  <activity>
    <user>jessewilson</user>
    <when>2004-03-30 18:29:15</when>
    <field_name>priority</field_name>
    <field_desc>Priority</field_desc>
    <oldvalue>P4</oldvalue>
    <newvalue>P2</newvalue>
  </activity>
  <activity>
    <user>jessewilson</user>
    <when>2004-04-03 20:18:55</when>
    <field_name>issue_status</field_name>
    <field_desc>Status</field_desc>
    <oldvalue>STARTED</oldvalue>
    <newvalue>RESOLVED</newvalue>
  </activity>
  <activity>
    <user>jessewilson</user>
    <when>2004-04-03 20:18:55</when>
    <field_name>resolution</field_name>
    <field_desc>Resolution</field_desc>
    <oldvalue></oldvalue>
    <newvalue>FIXED</newvalue>
  </activity>
  <activity>
    <user>jessewilson</user>
    <when>2004-05-21 14:19:41</when>
    <field_name>issue_status</field_name>
    <field_desc>Status</field_desc>
    <oldvalue>RESOLVED</oldvalue>
    <newvalue>CLOSED</newvalue>
  </activity>
</issue>
<issue status_code="200" status_message="OK">
  <issue_id>32</issue_id>
  <issue_status>NEW</issue_status>
  <priority>P5</priority>
  <resolution></resolution>
  <component>glazedlists</component>
  <version>current</version>
  <rep_platform>All</rep_platform>
  <assigned_to>kevinmaltby</assigned_to>
  <delta_ts>20040331184249</delta_ts>
  <subcomponent>www</subcomponent>
  <reporter>jessewilson</reporter>
  <target_milestone>milestone 1</target_milestone>
  <issue_type>ENHANCEMENT</issue_type>
  <creation_ts>2004-03-31 18:42:49</creation_ts>
  <qa_contact>issues@glazedlists</qa_contact>
  <status_whiteboard></status_whiteboard>
  <votes></votes>
  <op_sys>All</op_sys>
  <short_desc>CachingList could be more powerful</short_desc>
  <keywords></keywords>
  <long_desc>
   <who>jessewilson</who>
   <issue_when>2004-03-31 18:42:49</issue_when>
   <thetext>As Kevin and I were working on the CachingList problems today, we came up with some clever new 
ideas for a powerful replacement for CachingList:

 - background loading. Calls to get() return a default value immediately, then load the actual value in 
the background. Finally fire a updated() event when the actual value is loaded.

 - bulk loading via an API. Create a Caching API for performing BulkLoading. This is not really a 
MutationList because it would require more than an EventList as a source. Bulk loading could be faster 
but it is definitely a big fat ugly pig to implement.

 - footprint that is bounded by max cache size and NOT by the size of the source list. This will be 
necessary for arbitrarily large source lists on finitely powerful computers.

Regardless of where we go forward with Caching, it will be necessary to find some real-world cases that 
require caching before we commit serious time to the problem. Such cases will enable us to have a 
user's perspective on caching.</thetext>
  </long_desc>
</issue>
<issue status_code="200" status_message="OK">
  <issue_id>33</issue_id>
  <issue_status>CLOSED</issue_status>
  <priority>P2</priority>
  <resolution>FIXED</resolution>
  <component>glazedlists</component>
  <version>current</version>
  <rep_platform>All</rep_platform>
  <assigned_to>jessewilson</assigned_to>
  <delta_ts>20040521141946</delta_ts>
  <subcomponent>www</subcomponent>
  <reporter>jessewilson</reporter>
  <target_milestone>milestone 1</target_milestone>
  <issue_type>ENHANCEMENT</issue_type>
  <creation_ts>2004-04-03 20:20:10</creation_ts>
  <qa_contact>issues@glazedlists</qa_contact>
  <status_whiteboard></status_whiteboard>
  <votes></votes>
  <op_sys>All</op_sys>
  <short_desc>SortedList raw order support</short_desc>
  <keywords></keywords>
  <blocks>37</blocks>
  <long_desc>
   <who>jessewilson</who>
   <issue_when>2004-04-03 20:20:10</issue_when>
   <thetext>SortedList should support raw order when the current comparator is NULL.</thetext>
  </long_desc>
  <long_desc>
   <who>jessewilson</who>
   <issue_when>2004-04-05 13:00:09</issue_when>
   <thetext>This is now high priority as it is needed for making TableComparatorChooser work better.</thetext>
  </long_desc>
  <long_desc>
   <who>jessewilson</who>
   <issue_when>2004-04-09 08:27:19</issue_when>
   <thetext>Done!

Although the SortedList now supports raw-order sort, this is not supported by 
TableComparatorChooser.</thetext>
  </long_desc>
  <long_desc>
   <who>jessewilson</who>
   <issue_when>2004-05-21 14:19:46</issue_when>
   <thetext>This bug has been fixed for two weeks with no problems. I am marking it closed.</thetext>
  </long_desc>
  <activity>
    <user>jessewilson</user>
    <when>2004-04-05 13:00:09</when>
    <field_name>priority</field_name>
    <field_desc>Priority</field_desc>
    <oldvalue>P3</oldvalue>
    <newvalue>P2</newvalue>
  </activity>
  <activity>
    <user>jessewilson</user>
    <when>2004-04-08 08:56:02</when>
    <field_name>blocked</field_name>
    <field_desc>OtherIssuesDependingOnThis</field_desc>
    <oldvalue></oldvalue>
    <newvalue>37</newvalue>
  </activity>
  <activity>
    <user>jessewilson</user>
    <when>2004-04-09 08:27:19</when>
    <field_name>issue_status</field_name>
    <field_desc>Status</field_desc>
    <oldvalue>NEW</oldvalue>
    <newvalue>RESOLVED</newvalue>
  </activity>
  <activity>
    <user>jessewilson</user>
    <when>2004-04-09 08:27:19</when>
    <field_name>resolution</field_name>
    <field_desc>Resolution</field_desc>
    <oldvalue></oldvalue>
    <newvalue>FIXED</newvalue>
  </activity>
  <activity>
    <user>jessewilson</user>
    <when>2004-05-21 14:19:46</when>
    <field_name>issue_status</field_name>
    <field_desc>Status</field_desc>
    <oldvalue>RESOLVED</oldvalue>
    <newvalue>CLOSED</newvalue>
  </activity>
</issue>
<issue status_code="200" status_message="OK">
  <issue_id>34</issue_id>
  <issue_status>CLOSED</issue_status>
  <priority>P3</priority>
  <resolution>FIXED</resolution>
  <component>glazedlists</component>
  <version>current</version>
  <rep_platform>All</rep_platform>
  <assigned_to>issues@glazedlists</assigned_to>
  <delta_ts>20040521141953</delta_ts>
  <subcomponent>www</subcomponent>
  <reporter>kevinmaltby</reporter>
  <target_milestone>milestone 1</target_milestone>
  <issue_type>DEFECT</issue_type>
  <creation_ts>2004-04-07 22:33:08</creation_ts>
  <qa_contact>issues@glazedlists</qa_contact>
  <status_whiteboard></status_whiteboard>
  <votes></votes>
  <op_sys>All</op_sys>
  <short_desc>UniqueList sometimes does not forward events on a DELETE</short_desc>
  <keywords></keywords>
  <blocks>37</blocks>
  <long_desc>
   <who>kevinmaltby</who>
   <issue_when>2004-04-07 22:33:09</issue_when>
   <thetext>UniqueList currently does not forward events on when a DELETE is encountered in 
the following instance:

The element being removed is modelled in the unique view and has at least one 
duplicate.  This should result in the duplicate being modelled in the unique 
view and an update event being forwarded.

In some circumstances, such as on a call to clear() on the source list, 
forwarding this event causes the following exception:

Change blocks U.0 and D.0-1 intersect
java.lang.IllegalStateException: Change blocks U.0 and D.0-1 intersect
at com.odellengineeringltd.glazedlists.event.ListChangeBlock.requiresSwap
(ListChangeBlock.java:185)...

This fix will require altering the current strategy for dealing with change 
collisions in ListChangeBlock.</thetext>
  </long_desc>
  <long_desc>
   <who>kevinmaltby</who>
   <issue_when>2004-04-13 22:57:12</issue_when>
   <thetext>UniqueList now forwards events correctly in all cases when handling DELETE 
events.</thetext>
  </long_desc>
  <long_desc>
   <who>jessewilson</who>
   <issue_when>2004-05-21 14:19:53</issue_when>
   <thetext>This bug has been fixed for two weeks with no problems. I am marking it closed.</thetext>
  </long_desc>
  <activity>
    <user>jessewilson</user>
    <when>2004-04-08 08:56:02</when>
    <field_name>blocked</field_name>
    <field_desc>OtherIssuesDependingOnThis</field_desc>
    <oldvalue></oldvalue>
    <newvalue>37</newvalue>
  </activity>
  <activity>
    <user>kevinmaltby</user>
    <when>2004-04-13 22:57:12</when>
    <field_name>issue_status</field_name>
    <field_desc>Status</field_desc>
    <oldvalue>NEW</oldvalue>
    <newvalue>RESOLVED</newvalue>
  </activity>
  <activity>
    <user>kevinmaltby</user>
    <when>2004-04-13 22:57:12</when>
    <field_name>resolution</field_name>
    <field_desc>Resolution</field_desc>
    <oldvalue></oldvalue>
    <newvalue>FIXED</newvalue>
  </activity>
  <activity>
    <user>jessewilson</user>
    <when>2004-05-21 14:19:53</when>
    <field_name>issue_status</field_name>
    <field_desc>Status</field_desc>
    <oldvalue>RESOLVED</oldvalue>
    <newvalue>CLOSED</newvalue>
  </activity>
</issue>
<issue status_code="200" status_message="OK">
  <issue_id>35</issue_id>
  <issue_status>NEW</issue_status>
  <priority>P3</priority>
  <resolution></resolution>
  <component>glazedlists</component>
  <version>current</version>
  <rep_platform>All</rep_platform>
  <assigned_to>issues@glazedlists</assigned_to>
  <delta_ts>20040407223916</delta_ts>
  <subcomponent>www</subcomponent>
  <reporter>kevinmaltby</reporter>
  <target_milestone>milestone 1</target_milestone>
  <issue_type>ENHANCEMENT</issue_type>
  <creation_ts>2004-04-07 22:39:16</creation_ts>
  <qa_contact>issues@glazedlists</qa_contact>
  <status_whiteboard></status_whiteboard>
  <votes></votes>
  <op_sys>All</op_sys>
  <short_desc>UniqueList needs a means of forwarding non-mandatory change events</short_desc>
  <keywords></keywords>
  <blocks>36</blocks>
  <long_desc>
   <who>kevinmaltby</who>
   <issue_when>2004-04-07 22:39:16</issue_when>
   <thetext>UniqueList needs to provide access to non-mandatory change events for 
overlaying lists which want to listen to them.</thetext>
  </long_desc>
  <activity>
    <user>kevinmaltby</user>
    <when>2004-04-07 22:53:17</when>
    <field_name>blocked</field_name>
    <field_desc>OtherIssuesDependingOnThis</field_desc>
    <oldvalue></oldvalue>
    <newvalue>36</newvalue>
  </activity>
</issue>
<issue status_code="200" status_message="OK">
  <issue_id>36</issue_id>
  <issue_status>NEW</issue_status>
  <priority>P3</priority>
  <resolution></resolution>
  <component>glazedlists</component>
  <version>current</version>
  <rep_platform>All</rep_platform>
  <assigned_to>issues@glazedlists</assigned_to>
  <delta_ts>20040407225424</delta_ts>
  <subcomponent>www</subcomponent>
  <reporter>kevinmaltby</reporter>
  <target_milestone>milestone 1</target_milestone>
  <issue_type>FEATURE</issue_type>
  <creation_ts>2004-04-07 22:53:17</creation_ts>
  <qa_contact>issues@glazedlists</qa_contact>
  <status_whiteboard></status_whiteboard>
  <votes></votes>
  <op_sys>All</op_sys>
  <short_desc>GlazedLists requires a counted, unique view of a given list.</short_desc>
  <keywords></keywords>
  <dependson>35</dependson>
  <long_desc>
   <who>kevinmaltby</who>
   <issue_when>2004-04-07 22:53:17</issue_when>
   <thetext>This list type is based on the Bag ADT and is currently unnamed.

This class will sit on top of a UniqueList, and listen to all change events 
from the UniqueList to correctly provide access to not only a view which is 
guaranteed to be unique, but also the number of duplicate values for each 
unique value.

An example usage would be a list of votes for favourite pop.

Source         Unique View         Unique, Counted
------------------------------------------------------
Pepsi        | Coke              | Coke x 3
Coke         | MountainDew       | Mountain Dew
Sprite       | Pepsi             | Pepsi x 2
Pepsi        | Sprite            | Sprite
Mountain Dew |                   |
Coke         |                   |
Coke         |                   |
------------------------------------------------------

Clearly this could provide a valuable list view.</thetext>
  </long_desc>
  <long_desc>
   <who>kevinmaltby</who>
   <issue_when>2004-04-07 22:54:24</issue_when>
   <thetext>Specified an explicit dependency upon Issue 35.</thetext>
  </long_desc>
  <activity>
    <user>kevinmaltby</user>
    <when>2004-04-07 22:53:17</when>
    <field_name>dependson</field_name>
    <field_desc>IssuesThisDependsOn</field_desc>
    <oldvalue></oldvalue>
    <newvalue>35</newvalue>
  </activity>
</issue>
<issue status_code="200" status_message="OK">
  <issue_id>37</issue_id>
  <issue_status>CLOSED</issue_status>
  <priority>P3</priority>
  <resolution>FIXED</resolution>
  <component>glazedlists</component>
  <version>current</version>
  <rep_platform>All</rep_platform>
  <assigned_to>issues@glazedlists</assigned_to>
  <delta_ts>20040521142016</delta_ts>
  <subcomponent>www</subcomponent>
  <reporter>jessewilson</reporter>
  <target_milestone>milestone 1</target_milestone>
  <issue_type>TASK</issue_type>
  <creation_ts>2004-04-08 08:56:02</creation_ts>
  <qa_contact>issues@glazedlists</qa_contact>
  <status_whiteboard></status_whiteboard>
  <votes></votes>
  <op_sys>All</op_sys>
  <short_desc>Glazed Lists version 0.8 release</short_desc>
  <keywords></keywords>
  <dependson>27</dependson>
  <dependson>29</dependson>
  <dependson>30</dependson>
  <dependson>33</dependson>
  <dependson>34</dependson>
  <dependson>40</dependson>
  <long_desc>
   <who>jessewilson</who>
   <issue_when>2004-04-08 08:56:02</issue_when>
   <thetext>Glazed Lists version 0.8 is the last release before Glazed Lists undergoes the major API change.

Glazed Lists 0.8 will be a release that should be permanently available on the Glazed Lists webpage for 
existing users, but such users should be encouraged to migrate to Glazed Lists 0.9.

Glazed Lists v0.8 does not inlcude:
 - the renaming of APIs and classes
 - the new concurrency model

It depents upon the following issues:
 33 - SortedList raw order support
 34 - UniqueList sometimes does not forward events on a DELETE
 29 - ToString on BasicEventList, MutationList no good
 30 - Verify ListTable changeSizeRepaintAllThreshhold works</thetext>
  </long_desc>
  <long_desc>
   <who>jessewilson</who>
   <issue_when>2004-04-08 08:56:57</issue_when>
   <thetext>This issue depends on the outstanding bugs in the 0.8 release. It does not require new features or 
enhancements.</thetext>
  </long_desc>
  <long_desc>
   <who>jessewilson</who>
   <issue_when>2004-04-14 18:52:27</issue_when>
   <thetext>The 0.8 release can't be done until the SortedList is fixed and the UniqueList is finished (and verified)</thetext>
  </long_desc>
  <long_desc>
   <who>jessewilson</who>
   <issue_when>2004-04-17 17:21:45</issue_when>
   <thetext>Version 0.8 was released on April 15, 2004.</thetext>
  </long_desc>
  <long_desc>
   <who>jessewilson</who>
   <issue_when>2004-05-21 14:20:16</issue_when>
   <thetext>This bug has been fixed for two weeks with no problems. I am marking it closed.</thetext>
  </long_desc>
  <activity>
    <user>jessewilson</user>
    <when>2004-04-08 08:56:02</when>
    <field_name>dependson</field_name>
    <field_desc>IssuesThisDependsOn</field_desc>
    <oldvalue></oldvalue>
    <newvalue>29,30,33,34</newvalue>
  </activity>
  <activity>
    <user>jessewilson</user>
    <when>2004-04-08 08:56:57</when>
    <field_name>dependson</field_name>
    <field_desc>IssuesThisDependsOn</field_desc>
    <oldvalue>29,30,33,34</oldvalue>
    <newvalue>27,29,30,33,34,40</newvalue>
  </activity>
  <activity>
    <user>jessewilson</user>
    <when>2004-04-17 17:21:45</when>
    <field_name>issue_status</field_name>
    <field_desc>Status</field_desc>
    <oldvalue>NEW</oldvalue>
    <newvalue>RESOLVED</newvalue>
  </activity>
  <activity>
    <user>jessewilson</user>
    <when>2004-04-17 17:21:45</when>
    <field_name>resolution</field_name>
    <field_desc>Resolution</field_desc>
    <oldvalue></oldvalue>
    <newvalue>FIXED</newvalue>
  </activity>
  <activity>
    <user>jessewilson</user>
    <when>2004-05-21 14:20:16</when>
    <field_name>issue_status</field_name>
    <field_desc>Status</field_desc>
    <oldvalue>RESOLVED</oldvalue>
    <newvalue>CLOSED</newvalue>
  </activity>
</issue>
<issue status_code="200" status_message="OK">
  <issue_id>38</issue_id>
  <issue_status>CLOSED</issue_status>
  <priority>P4</priority>
  <resolution>FIXED</resolution>
  <component>glazedlists</component>
  <version>current</version>
  <rep_platform>All</rep_platform>
  <assigned_to>issues@glazedlists</assigned_to>
  <delta_ts>20040521142032</delta_ts>
  <subcomponent>www</subcomponent>
  <reporter>jessewilson</reporter>
  <target_milestone>milestone 1</target_milestone>
  <issue_type>DEFECT</issue_type>
  <creation_ts>2004-04-08 08:59:21</creation_ts>
  <qa_contact>issues@glazedlists</qa_contact>
  <status_whiteboard></status_whiteboard>
  <votes></votes>
  <op_sys>All</op_sys>
  <short_desc>TableComparatorChooser icon can get out of sync</short_desc>
  <keywords></keywords>
  <long_desc>
   <who>jessewilson</who>
   <issue_when>2004-04-08 08:59:21</issue_when>
   <thetext>When the sorting of a list changes, the TableComparatorChooser fails to respond to this change 
appropriately. The TableComparatorChooser should show the proper icon, even if the sorted list's 
comparator was selected elsewhere.</thetext>
  </long_desc>
  <long_desc>
   <who>kevinmaltby</who>
   <issue_when>2004-04-09 16:40:02</issue_when>
   <thetext>TableComparatorChooser now responds to sorting criteria changing externally.</thetext>
  </long_desc>
  <long_desc>
   <who>jessewilson</who>
   <issue_when>2004-05-21 14:20:32</issue_when>
   <thetext>This bug has been fixed for two weeks with no problems. I am marking it closed.</thetext>
  </long_desc>
  <activity>
    <user>kevinmaltby</user>
    <when>2004-04-09 16:40:02</when>
    <field_name>issue_status</field_name>
    <field_desc>Status</field_desc>
    <oldvalue>NEW</oldvalue>
    <newvalue>RESOLVED</newvalue>
  </activity>
  <activity>
    <user>kevinmaltby</user>
    <when>2004-04-09 16:40:02</when>
    <field_name>resolution</field_name>
    <field_desc>Resolution</field_desc>
    <oldvalue></oldvalue>
    <newvalue>FIXED</newvalue>
  </activity>
  <activity>
    <user>jessewilson</user>
    <when>2004-05-21 14:20:32</when>
    <field_name>issue_status</field_name>
    <field_desc>Status</field_desc>
    <oldvalue>RESOLVED</oldvalue>
    <newvalue>CLOSED</newvalue>
  </activity>
</issue>
<issue status_code="200" status_message="OK">
  <issue_id>39</issue_id>
  <issue_status>NEW</issue_status>
  <priority>P4</priority>
  <resolution></resolution>
  <component>glazedlists</component>
  <version>current</version>
  <rep_platform>All</rep_platform>
  <assigned_to>issues@glazedlists</assigned_to>
  <delta_ts>20040413134126</delta_ts>
  <subcomponent>www</subcomponent>
  <reporter>jessewilson</reporter>
  <target_milestone>milestone 1</target_milestone>
  <issue_type>DEFECT</issue_type>
  <creation_ts>2004-04-13 13:41:26</creation_ts>
  <qa_contact>issues@glazedlists</qa_contact>
  <status_whiteboard></status_whiteboard>
  <votes></votes>
  <op_sys>All</op_sys>
  <short_desc>Sorting clears selection</short_desc>
  <keywords></keywords>
  <long_desc>
   <who>jessewilson</who>
   <issue_when>2004-04-13 13:41:26</issue_when>
   <thetext>This problem will be very difficult to solve using the current Glazed Lists framework, but it is a valid 
problem. Sorting clears the selection. 

The only fix I can think of is to add a new type of event alongside INSERT, UPDATE and DELETE which is 
called MOVE. I think it is kind of an ugly hack on principal because it will impact all other lists if it is 
implemented. 

I will have to give this one some more thought. Saving selection by value may be one option but that is 
also rather a big ugly hack.</thetext>
  </long_desc>
</issue>
<issue status_code="200" status_message="OK">
  <issue_id>40</issue_id>
  <issue_status>CLOSED</issue_status>
  <priority>P2</priority>
  <resolution>FIXED</resolution>
  <component>glazedlists</component>
  <version>current</version>
  <rep_platform>All</rep_platform>
  <assigned_to>jessewilson</assigned_to>
  <delta_ts>20040521141933</delta_ts>
  <subcomponent>www</subcomponent>
  <reporter>jessewilson</reporter>
  <target_milestone>milestone 1</target_milestone>
  <issue_type>DEFECT</issue_type>
  <creation_ts>2004-04-14 18:50:07</creation_ts>
  <qa_contact>issues@glazedlists</qa_contact>
  <status_whiteboard></status_whiteboard>
  <votes></votes>
  <op_sys>All</op_sys>
  <short_desc>Sorted List fails upon intensive filtering</short_desc>
  <keywords></keywords>
  <blocks>27</blocks>
  <blocks>37</blocks>
  <long_desc>
   <who>jessewilson</who>
   <issue_when>2004-04-14 18:50:07</issue_when>
   <thetext>SortedList fails upon an intensive amount of filtering. The SortedListTest must be updated to catch this 
failure and the SortedList should also be fixed to remedy the problem.

    [junit] FILTER: 4, 5, 1, 6, 2, 3, 2, 8, 1, 3, 
    [junit] SORTED: 1, 1, 2, 3, 2, 3, 4, 8, 5, 6,</thetext>
  </long_desc>
  <long_desc>
   <who>jessewilson</who>
   <issue_when>2004-04-15 12:59:13</issue_when>
   <thetext>I was processing the events in the ListChangeEvent in a manner that was unsafe when there were 
inserts mixed with deletes.

The SortedList now fires all delete events first, and then goes on to handle the inserts and updates 
later.
</thetext>
  </long_desc>
  <long_desc>
   <who>jessewilson</who>
   <issue_when>2004-05-21 14:19:33</issue_when>
   <thetext>This bug has been fixed for two weeks with no problems. I am marking it closed.</thetext>
  </long_desc>
  <activity>
    <user>jessewilson</user>
    <when>2004-04-11 16:46:07</when>
    <field_name>blocked</field_name>
    <field_desc>OtherIssuesDependingOnThis</field_desc>
    <oldvalue></oldvalue>
    <newvalue>27</newvalue>
  </activity>
  <activity>
    <user>jessewilson</user>
    <when>2004-04-08 08:56:57</when>
    <field_name>blocked</field_name>
    <field_desc>OtherIssuesDependingOnThis</field_desc>
    <oldvalue>27</oldvalue>
    <newvalue>27,37</newvalue>
  </activity>
  <activity>
    <user>jessewilson</user>
    <when>2004-04-15 12:59:13</when>
    <field_name>issue_status</field_name>
    <field_desc>Status</field_desc>
    <oldvalue>NEW</oldvalue>
    <newvalue>RESOLVED</newvalue>
  </activity>
  <activity>
    <user>jessewilson</user>
    <when>2004-04-15 12:59:13</when>
    <field_name>resolution</field_name>
    <field_desc>Resolution</field_desc>
    <oldvalue></oldvalue>
    <newvalue>FIXED</newvalue>
  </activity>
  <activity>
    <user>jessewilson</user>
    <when>2004-05-21 14:19:33</when>
    <field_name>issue_status</field_name>
    <field_desc>Status</field_desc>
    <oldvalue>RESOLVED</oldvalue>
    <newvalue>CLOSED</newvalue>
  </activity>
</issue>
<issue status_code="200" status_message="OK">
  <issue_id>41</issue_id>
  <issue_status>RESOLVED</issue_status>
  <priority>P3</priority>
  <resolution>FIXED</resolution>
  <component>glazedlists</component>
  <version>current</version>
  <rep_platform>All</rep_platform>
  <assigned_to>issues@glazedlists</assigned_to>
  <delta_ts>20040602231024</delta_ts>
  <subcomponent>www</subcomponent>
  <reporter>jessewilson</reporter>
  <target_milestone>milestone 1</target_milestone>
  <issue_type>TASK</issue_type>
  <creation_ts>2004-05-21 14:33:32</creation_ts>
  <qa_contact>issues@glazedlists</qa_contact>
  <status_whiteboard></status_whiteboard>
  <votes></votes>
  <op_sys>All</op_sys>
  <short_desc>Glazed Lists version 0.9 release</short_desc>
  <keywords></keywords>
  <dependson>20</dependson>
  <dependson>26</dependson>
  <long_desc>
   <who>jessewilson</who>
   <issue_when>2004-05-21 14:33:32</issue_when>
   <thetext>This issue depends upon all issues to be resolved for the 0.9 release.

These issues include the name refactoring and API stability.

Glazed Lists 0.9 is a release intended to have 100% compatibility with 1.0. This includes:
 - class &amp; package names
 - concurrency strategy
 - event sequence strategy</thetext>
  </long_desc>
  <long_desc>
   <who>jessewilson</who>
   <issue_when>2004-05-21 14:34:50</issue_when>
   <thetext>This release depends upon the 0.9 issues.</thetext>
  </long_desc>
  <long_desc>
   <who>jessewilson</who>
   <issue_when>2004-06-02 15:31:50</issue_when>
   <thetext>TO DO, left in this release, off the top of my head:
* make final classes final
* determine where EventList iterator/sublist goes
* tutorial? may defer to 1.0
* rename main package (ca.odell.glazedlists)
* port Query stuff to use UniqueList, move package to migrationkit
* move DEMO out of Javadocs (new demo for 1.0 definitely needed)
* change TableFormat to not include configureTable() method</thetext>
  </long_desc>
  <long_desc>
   <who>jessewilson</who>
   <issue_when>2004-06-02 23:10:24</issue_when>
   <thetext>Released!</thetext>
  </long_desc>
  <activity>
    <user>jessewilson</user>
    <when>2004-05-21 14:34:50</when>
    <field_name>dependson</field_name>
    <field_desc>IssuesThisDependsOn</field_desc>
    <oldvalue></oldvalue>
    <newvalue>20,26</newvalue>
  </activity>
  <activity>
    <user>jessewilson</user>
    <when>2004-05-21 14:34:50</when>
    <field_name>issue_status</field_name>
    <field_desc>Status</field_desc>
    <oldvalue>NEW</oldvalue>
    <newvalue>STARTED</newvalue>
  </activity>
  <activity>
    <user>jessewilson</user>
    <when>2004-06-02 23:10:24</when>
    <field_name>issue_status</field_name>
    <field_desc>Status</field_desc>
    <oldvalue>STARTED</oldvalue>
    <newvalue>RESOLVED</newvalue>
  </activity>
  <activity>
    <user>jessewilson</user>
    <when>2004-06-02 23:10:24</when>
    <field_name>resolution</field_name>
    <field_desc>Resolution</field_desc>
    <oldvalue></oldvalue>
    <newvalue>FIXED</newvalue>
  </activity>
</issue>
<issue status_code="200" status_message="OK">
  <issue_id>42</issue_id>
  <issue_status>CLOSED</issue_status>
  <priority>P3</priority>
  <resolution>FIXED</resolution>
  <component>glazedlists</component>
  <version>current</version>
  <rep_platform>All</rep_platform>
  <assigned_to>issues@glazedlists</assigned_to>
  <delta_ts>20040609143521</delta_ts>
  <subcomponent>www</subcomponent>
  <reporter>jessewilson</reporter>
  <target_milestone>milestone 1</target_milestone>
  <issue_type>DEFECT</issue_type>
  <creation_ts>2004-05-21 14:38:14</creation_ts>
  <qa_contact>issues@glazedlists</qa_contact>
  <status_whiteboard></status_whiteboard>
  <votes></votes>
  <op_sys>All</op_sys>
  <short_desc>Enable concurrent mutation list modifications</short_desc>
  <keywords></keywords>
  <long_desc>
   <who>jessewilson</who>
   <issue_when>2004-05-21 14:38:14</issue_when>
   <thetext>Currently the reader/writer locks lock ALL lists when any mutation list is being modified (ie. re-sorted).

The reader/writer locks should be changed to only lock dependent lists when such a modification takes 
place.

This applies to:
 - AbstractFilterList
 - SortedList
 - UniqueList
 - CachingList
 - and potentially others</thetext>
  </long_desc>
  <long_desc>
   <who>jessewilson</who>
   <issue_when>2004-05-21 17:11:14</issue_when>
   <thetext>Fixed . . . now the SortedList and AbstractFilterList can sort or filter multiple lists with the same source 
simultaneously. This uses the new InternalReadWriteLock which delegates locking to a pair of 
ReadWriteLocks.</thetext>
  </long_desc>
  <long_desc>
   <who>jessewilson</who>
   <issue_when>2004-06-09 14:35:21</issue_when>
   <thetext>This bug has been fixed for two weeks with no problems. I am marking it closed.</thetext>
  </long_desc>
  <activity>
    <user>jessewilson</user>
    <when>2004-05-21 17:11:14</when>
    <field_name>issue_status</field_name>
    <field_desc>Status</field_desc>
    <oldvalue>NEW</oldvalue>
    <newvalue>RESOLVED</newvalue>
  </activity>
  <activity>
    <user>jessewilson</user>
    <when>2004-05-21 17:11:14</when>
    <field_name>resolution</field_name>
    <field_desc>Resolution</field_desc>
    <oldvalue></oldvalue>
    <newvalue>FIXED</newvalue>
  </activity>
  <activity>
    <user>jessewilson</user>
    <when>2004-06-09 14:35:21</when>
    <field_name>issue_status</field_name>
    <field_desc>Status</field_desc>
    <oldvalue>RESOLVED</oldvalue>
    <newvalue>CLOSED</newvalue>
  </activity>
</issue>
<issue status_code="200" status_message="OK">
  <issue_id>43</issue_id>
  <issue_status>NEW</issue_status>
  <priority>P5</priority>
  <resolution></resolution>
  <component>glazedlists</component>
  <version>current</version>
  <rep_platform>All</rep_platform>
  <assigned_to>issues@glazedlists</assigned_to>
  <delta_ts>20040521171310</delta_ts>
  <subcomponent>www</subcomponent>
  <reporter>jessewilson</reporter>
  <target_milestone>milestone 1</target_milestone>
  <issue_type>DEFECT</issue_type>
  <creation_ts>2004-05-21 17:13:10</creation_ts>
  <qa_contact>issues@glazedlists</qa_contact>
  <status_whiteboard></status_whiteboard>
  <votes></votes>
  <op_sys>All</op_sys>
  <short_desc>Potential deadlock in CachingList</short_desc>
  <keywords></keywords>
  <long_desc>
   <who>jessewilson</who>
   <issue_when>2004-05-21 17:13:10</issue_when>
   <thetext>The CachingList acquires a WriteLock when it may already have a ReadLock.

This is DANGEROUS! It is possible that two CachingLists may each have readlocks, and contest over a 
write lock to their doom!</thetext>
  </long_desc>
</issue>
<issue status_code="200" status_message="OK">
  <issue_id>44</issue_id>
  <issue_status>RESOLVED</issue_status>
  <priority>P2</priority>
  <resolution>FIXED</resolution>
  <component>glazedlists</component>
  <version>current</version>
  <rep_platform>All</rep_platform>
  <assigned_to>issues@glazedlists</assigned_to>
  <delta_ts>20040602121605</delta_ts>
  <subcomponent>www</subcomponent>
  <reporter>jessewilson</reporter>
  <target_milestone>milestone 1</target_milestone>
  <issue_type>DEFECT</issue_type>
  <creation_ts>2004-06-02 08:23:59</creation_ts>
  <qa_contact>issues@glazedlists</qa_contact>
  <status_whiteboard></status_whiteboard>
  <votes></votes>
  <op_sys>All</op_sys>
  <short_desc>remove(object), clear() can have unwanted side effects</short_desc>
  <keywords></keywords>
  <long_desc>
   <who>jessewilson</who>
   <issue_when>2004-06-02 08:23:59</issue_when>
   <thetext>Suppose we have a List "alphabet" containing "A", "B", "C", "D", "E", "F".
If we call alphabet.subList(1, 3).clear(), then the list alphabet should change to "A", "D", "E", "F".
But Glazed Lists clears the entire list alphabet.

Similar problems exist upon clearing filtered lists, etc.

This problem exists in the following List methods:
clear()
remove(Object)
removeAll(Collection)
retainAll(Collection)</thetext>
  </long_desc>
  <long_desc>
   <who>jessewilson</who>
   <issue_when>2004-06-02 12:16:05</issue_when>
   <thetext>Fixed! Hopefully, this doesn't ruin any code in place because the behaviour of SubList etc.
are now correct. Existing code could possibly depend on the incorrect implementations!
Hopefully that does not prove to be a problem.

This fix allows us to do cool things, as I will demonstrate:

Suppose we have a list, alphabet composed of { A, B, C, D, E, F, G, H, I, J, K }
And we constructed a transformed list vowels, which filtered alphabet to { A, E, I }
Then if we do vowels.clear(), we get the following result:
alphabet becomes: B, C, D, F, G, H, J, K

Cool, no? This would be made more powerful with a better example. Perhaps a list of email addresses, 
and a filter list that picks the SPAM or whatever.</thetext>
  </long_desc>
  <activity>
    <user>jessewilson</user>
    <when>2004-06-02 12:16:05</when>
    <field_name>issue_status</field_name>
    <field_desc>Status</field_desc>
    <oldvalue>NEW</oldvalue>
    <newvalue>RESOLVED</newvalue>
  </activity>
  <activity>
    <user>jessewilson</user>
    <when>2004-06-02 12:16:05</when>
    <field_name>resolution</field_name>
    <field_desc>Resolution</field_desc>
    <oldvalue></oldvalue>
    <newvalue>FIXED</newvalue>
  </activity>
</issue>
<issue status_code="200" status_message="OK">
  <issue_id>45</issue_id>
  <issue_status>RESOLVED</issue_status>
  <priority>P2</priority>
  <resolution>FIXED</resolution>
  <component>glazedlists</component>
  <version>current</version>
  <rep_platform>All</rep_platform>
  <assigned_to>issues@glazedlists</assigned_to>
  <delta_ts>20040602134840</delta_ts>
  <subcomponent>www</subcomponent>
  <reporter>jessewilson</reporter>
  <target_milestone>milestone 1</target_milestone>
  <issue_type>ENHANCEMENT</issue_type>
  <creation_ts>2004-06-02 12:18:56</creation_ts>
  <qa_contact>issues@glazedlists</qa_contact>
  <status_whiteboard></status_whiteboard>
  <votes></votes>
  <op_sys>All</op_sys>
  <short_desc>Add write functionality to UniqueList</short_desc>
  <keywords></keywords>
  <long_desc>
   <who>jessewilson</who>
   <issue_when>2004-06-02 12:18:56</issue_when>
   <thetext>The UniqueList should be writable. Some write methods to include:

add(), remove(), set() . . .

The most interesting ones to implement will be the remove() methods as they may require removing 
multiple duplicates from the source list.</thetext>
  </long_desc>
  <long_desc>
   <who>jessewilson</who>
   <issue_when>2004-06-02 13:48:40</issue_when>
   <thetext>I have added write support to UniqueList.

There is an interesting problem posed by supporting writing in UniqueList, as well as writing in other 
code already implemented via bug 44.

Methods such as clear() on a filter list may call several remove() methods on the underlying source list. 
These remove() methods fire the event listeners and other lists receive notification for each of many 
removes within a clear. Such listeners will likely read from their source list to respond to the change, 
and it is possible that this source list is still in the process of changing due to the clear() method. 
Therefore:
 - such methods that call multiple changing methods on their source list must be in a consistent state 
for each such method call
 - such methods must be implemented in a way that safely handles receiving a change event after each 
source list modification.

These multiple source method calling lists are troublesome and it may be worthwhile to find a way to 
bundle a set of methods to invoke on a source list as a group. This is a sophisticated problem and will 
require some research. For the time being, guaranteeing consistency and event safety should be 
sufficient.</thetext>
  </long_desc>
  <activity>
    <user>jessewilson</user>
    <when>2004-06-02 13:48:40</when>
    <field_name>issue_status</field_name>
    <field_desc>Status</field_desc>
    <oldvalue>NEW</oldvalue>
    <newvalue>RESOLVED</newvalue>
  </activity>
  <activity>
    <user>jessewilson</user>
    <when>2004-06-02 13:48:40</when>
    <field_name>resolution</field_name>
    <field_desc>Resolution</field_desc>
    <oldvalue></oldvalue>
    <newvalue>FIXED</newvalue>
  </activity>
</issue>
<issue status_code="200" status_message="OK">
  <issue_id>46</issue_id>
  <issue_status>NEW</issue_status>
  <priority>P4</priority>
  <resolution></resolution>
  <component>glazedlists</component>
  <version>current</version>
  <rep_platform>All</rep_platform>
  <assigned_to>issues@glazedlists</assigned_to>
  <delta_ts>20040603053607</delta_ts>
  <subcomponent>www</subcomponent>
  <reporter>jessewilson</reporter>
  <target_milestone>milestone 1</target_milestone>
  <issue_type>DEFECT</issue_type>
  <creation_ts>2004-06-03 05:36:07</creation_ts>
  <qa_contact>issues@glazedlists</qa_contact>
  <status_whiteboard></status_whiteboard>
  <votes></votes>
  <op_sys>All</op_sys>
  <short_desc>UniqueList, FilterList fire multiple events for some operations</short_desc>
  <keywords></keywords>
  <long_desc>
   <who>jessewilson</who>
   <issue_when>2004-06-03 05:36:07</issue_when>
   <thetext>UniqueList.clear(), FilterList.clear(), SubList.clear() all can fire multiple ListEvents when only a single 
operation is performed upon them.

This can be fixed by causing such lists to not propogate changes until they are all done.</thetext>
  </long_desc>
</issue>
<issue status_code="200" status_message="OK">
  <issue_id>47</issue_id>
  <issue_status>NEW</issue_status>
  <priority>P3</priority>
  <resolution></resolution>
  <component>glazedlists</component>
  <version>current</version>
  <rep_platform>All</rep_platform>
  <assigned_to>issues@glazedlists</assigned_to>
  <delta_ts>20040603053931</delta_ts>
  <subcomponent>www</subcomponent>
  <reporter>jessewilson</reporter>
  <target_milestone>milestone 1</target_milestone>
  <issue_type>ENHANCEMENT</issue_type>
  <creation_ts>2004-06-03 05:39:31</creation_ts>
  <qa_contact>issues@glazedlists</qa_contact>
  <status_whiteboard></status_whiteboard>
  <votes></votes>
  <op_sys>All</op_sys>
  <short_desc>Threshhold List</short_desc>
  <keywords></keywords>
  <long_desc>
   <who>jessewilson</who>
   <issue_when>2004-06-03 05:39:31</issue_when>
   <thetext>Suppose we have a list of Objects, each of which has a date created.

It should be possible to create a filter that filters for where the date created is less than or greater than 
a specified threshhold. This should be possible for any criteria that can take a range of values - in 
effect anything that is Comparable.

Currently this is possible using the AbstractFilterList, but it is not 'smart' enough to know how 
adjustments in the criteria require only a subset of the values to be readjusted. A clever implementation 
of this would use a sorted set, and binary search to find the seperator between those that meet the 
criteria and those that do not.

I was thinking a "Date Slider" Swing widget would be a good prototype of this!</thetext>
  </long_desc>
</issue>
<issue status_code="200" status_message="OK">
  <issue_id>48</issue_id>
  <issue_status>RESOLVED</issue_status>
  <priority>P3</priority>
  <resolution>FIXED</resolution>
  <component>glazedlists</component>
  <version>current</version>
  <rep_platform>All</rep_platform>
  <assigned_to>issues@glazedlists</assigned_to>
  <delta_ts>20040603130359</delta_ts>
  <subcomponent>www</subcomponent>
  <reporter>jessewilson</reporter>
  <target_milestone>milestone 1</target_milestone>
  <issue_type>DEFECT</issue_type>
  <creation_ts>2004-06-03 13:02:42</creation_ts>
  <qa_contact>issues@glazedlists</qa_contact>
  <status_whiteboard></status_whiteboard>
  <votes></votes>
  <op_sys>All</op_sys>
  <short_desc>Migrationkit's DynamicQueryList fails to forward events</short_desc>
  <keywords></keywords>
  <long_desc>
   <who>jessewilson</who>
   <issue_when>2004-06-03 13:02:42</issue_when>
   <thetext>The Migrationkit's DynamicQueryList class is not forwarding events.</thetext>
  </long_desc>
  <long_desc>
   <who>jessewilson</who>
   <issue_when>2004-06-03 13:03:59</issue_when>
   <thetext>This bug has already been fixed.

The fix is NOT in the Glazed Lists 0.9 release, but it will be in the next Glazed Lists release. The fix is 
also available via CVS.</thetext>
  </long_desc>
  <activity>
    <user>jessewilson</user>
    <when>2004-06-03 13:03:59</when>
    <field_name>issue_status</field_name>
    <field_desc>Status</field_desc>
    <oldvalue>NEW</oldvalue>
    <newvalue>RESOLVED</newvalue>
  </activity>
  <activity>
    <user>jessewilson</user>
    <when>2004-06-03 13:03:59</when>
    <field_name>resolution</field_name>
    <field_desc>Resolution</field_desc>
    <oldvalue></oldvalue>
    <newvalue>FIXED</newvalue>
  </activity>
</issue>
<issue status_code="200" status_message="OK">
  <issue_id>49</issue_id>
  <issue_status>NEW</issue_status>
  <priority>P3</priority>
  <resolution></resolution>
  <component>glazedlists</component>
  <version>current</version>
  <rep_platform>All</rep_platform>
  <assigned_to>issues@glazedlists</assigned_to>
  <delta_ts>20040603134613</delta_ts>
  <subcomponent>www</subcomponent>
  <reporter>jessewilson</reporter>
  <target_milestone>milestone 1</target_milestone>
  <issue_type>TASK</issue_type>
  <creation_ts>2004-06-03 13:46:13</creation_ts>
  <qa_contact>issues@glazedlists</qa_contact>
  <status_whiteboard></status_whiteboard>
  <votes></votes>
  <op_sys>All</op_sys>
  <short_desc>Tutorial v. 0.9</short_desc>
  <keywords></keywords>
  <long_desc>
   <who>jessewilson</who>
   <issue_when>2004-06-03 13:46:13</issue_when>
   <thetext>Glazed Lists needs a new tutorial. It would be great if this tutorial involved a newer, more exciting and 
more powerful demo app.

My current two ideas are:
 - a bugzilla XML browser
 - a Pop3 client

Such involve lots of lists and could take good advantage of Glazed Lists' ability to transform lists.

The demo should involve:
 - Multiple-criterea sorting
 - Text Filtering &amp; Custom Filtering
 - UniqueList, UniqueList on a derived list
 - Transformed List
 - JTable, JComboBox &amp; JList

The demo should not rely on third-party libraries or tools for simplicity.</thetext>
  </long_desc>
</issue>
<issue status_code="200" status_message="OK">
  <issue_id>50</issue_id>
  <issue_status>NEW</issue_status>
  <priority>P4</priority>
  <resolution></resolution>
  <component>glazedlists</component>
  <version>current</version>
  <rep_platform>All</rep_platform>
  <assigned_to>issues@glazedlists</assigned_to>
  <delta_ts>20040605085016</delta_ts>
  <subcomponent>www</subcomponent>
  <reporter>jessewilson</reporter>
  <target_milestone>milestone 1</target_milestone>
  <issue_type>ENHANCEMENT</issue_type>
  <creation_ts>2004-06-05 08:50:16</creation_ts>
  <qa_contact>issues@glazedlists</qa_contact>
  <status_whiteboard></status_whiteboard>
  <votes></votes>
  <op_sys>All</op_sys>
  <short_desc>SWT Support</short_desc>
  <keywords></keywords>
  <long_desc>
   <who>jessewilson</who>
   <issue_when>2004-06-05 08:50:16</issue_when>
   <thetext>Glazed Lists does not support SWT. This toolkit is growing in importance and Glazed Lists is well suited 
for this platform.

Some things to consider:
 - I need an SWT 'expert', either by becoming one or by finding a volunteer
 - SWT compilation into the .jar file must be conditional. SWT support should be in source-form only 
and compiled only if SWT classes are available on the user's class path.
 - From my initial research, SWT is not as model-driven as Swing. Although this does not pose a 
problem it may require a change in approach
 - We need to choose an SWT version to support. 3.0 is coming out soon but I have no idea what the 
actual SWT users in the field are using.</thetext>
  </long_desc>
</issue>
<issue status_code="200" status_message="OK">
  <issue_id>51</issue_id>
  <issue_status>NEW</issue_status>
  <priority>P3</priority>
  <resolution></resolution>
  <component>glazedlists</component>
  <version>current</version>
  <rep_platform>All</rep_platform>
  <assigned_to>issues@glazedlists</assigned_to>
  <delta_ts>20040609205635</delta_ts>
  <subcomponent>www</subcomponent>
  <reporter>jessewilson</reporter>
  <target_milestone>milestone 1</target_milestone>
  <issue_type>TASK</issue_type>
  <creation_ts>2004-06-09 20:56:35</creation_ts>
  <qa_contact>issues@glazedlists</qa_contact>
  <status_whiteboard></status_whiteboard>
  <votes></votes>
  <op_sys>All</op_sys>
  <short_desc>Implement Chunk Transfer Protocol client &amp; servers</short_desc>
  <keywords></keywords>
  <long_desc>
   <who>jessewilson</who>
   <issue_when>2004-06-09 20:56:35</issue_when>
   <thetext>We have hacked out a basic plan for the initial network protocol for Glazed Lists.

We are going to use a layered protocol to isolate concerns:
 - "Chunk Transfer Protocol" is our base protocol. This is a simplification of HTTP/1.1 with chunked 
encoding. We would like Glazed Lists to work through HTTP proxies and HTTP-aware firewalls so this 
protocol shall be a subset of HTTP/1.1.
 - "Update Subscription Protocol" is an update-push protocol that sits on top of CTP and adds some 
application-specific features. This will initially consist of update sequencing. Eventual features for this 
are digitally signed updates, peer-to-peer support and NAT evasion.
 - Glazed Lists on the network will specify an encoding for list updates that can be transferred via USP. 

All encodings must have the following properties:
 - well documented to allow for alternative implementations
 - extendible without breaking clients using previous versions
 - language and platform neutral
 - simple!

All that said, we need to implement the first step, Chunk Transfer Protocol. Here are the interfaces for 
the initial version of CTP:

CTPServerProtocol
void sendResponse(int code, Map headers) throws CTPException;
void sendChunk(byte[] data) throws CTPException;
void close();
CTPServerHandler
void receiveGet(CTPServerProtocol source, String uri, Map headers);
void connectionClosed(CTPServerProtocol source, Exception reason);

CTPClientProtocol
void sendGet(String uri, Map headers) throws CTPException;
void close();
CTPClientHandler
void receiveResponse(CTPClientProtocol source, int code, Map headers);
void receiveChunk(CTPClientProtocol source, byte[] data);
void connectionClosed(CTPClientProtocol source, Exception reason);

It should be straightforward to create a simple implementation that uses sockets. This design should 
also hopefully be extendable for use with Java's buffered IO, java.nio.</thetext>
  </long_desc>
</issue>
<issue status_code="200" status_message="OK">
  <issue_id>52</issue_id>
  <issue_status>NEW</issue_status>
  <priority>P3</priority>
  <resolution></resolution>
  <component>glazedlists</component>
  <version>current</version>
  <rep_platform>All</rep_platform>
  <assigned_to>issues@glazedlists</assigned_to>
  <delta_ts>20040610080733</delta_ts>
  <subcomponent>www</subcomponent>
  <reporter>jessewilson</reporter>
  <target_milestone>milestone 1</target_milestone>
  <issue_type>DEFECT</issue_type>
  <creation_ts>2004-06-10 08:07:33</creation_ts>
  <qa_contact>issues@glazedlists</qa_contact>
  <status_whiteboard></status_whiteboard>
  <votes></votes>
  <op_sys>All</op_sys>
  <short_desc>Support 'nested' change events</short_desc>
  <keywords></keywords>
  <long_desc>
   <who>jessewilson</who>
   <issue_when>2004-06-10 08:07:33</issue_when>
   <thetext>Adding support for nested change events may simplify the code and may even make it more powerful.

Currently, some classes such as TransformationList implement clear(), removeAll() etc. as a series of 
remove() calls. This fires a series of events when only one event should be fired.

The solution is to create 'nested' change events such as
beginNestedChange()
commitNestedChange()

which can contain within it many calls to beginChange() / commitChange(), where such commits do not 
actually send the events.</thetext>
  </long_desc>
</issue>
</issuezilla>