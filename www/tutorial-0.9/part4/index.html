<html>
<head><title>Glazed Lists Tutorial Part 4 - TransformedList and UniqueList</title>
</head>
<body>
<div class="app">

<h3>Glazed Lists Tutorial</h3>
<h1>Part 4 - TransformedList and UniqueList</h1>

<p>In part four of this tutorial, we compose a list of users derived from the
list of issues. Each issue has a user, so we extract all users from all issues
to form a new list. The derived list is also a <code>EventList</code> so we can apply
filtering and sorting to it in turn. In part five we use our derived users list
to filter for issues belonging to a selected user.

<h3>ListEvents and ListEventAssembler</h3>

<p>Earlier in the tutorial we discussed how Glazed Lists uses events to
propagate changes to <code>TransformedLists</code> and widgets. Although this had been
significant in understanding how <code>EventList</code>s work, it was
not necessary to interact with the event and listener code directly. In
this stage we create a custom transformation and require some of the event
and listener code in the process.

<p><code>ListEvent</code>s are sophisticated event objects. Each event
notification may contain information on hundreds of inserts, updates and
deletes within a list. To simplify the process, the <code>ListEventAssembler</code>
class assembles and manages <code>ListEvent</code>s and their listeners.
The <code>ListEventAssembler</code> has methods <code>addInsert(index)</code>, 
<code>addUpdate(index)</code> and <code>addDelete(index)</code> to be called
with each list add(), set() and remove(), respectively. Finally it has a pair
of methods <code>beginEvent()</code> and <code>commitEvent()</code> that prepare
for and fire the event to listeners.

<h3>TransformedList and ListEvents</h3>

<p>Fortunately we only need to create a simple <code>ListEvent</code>s. Our
goal is to create a list containing the users for each issue. For example, if
the first element of our issue list contained an Issue object that belonged to
user "jessewilson", then the first element of our users list will simply contain
the element "jessewilson". The size of our users list will be exactly the same
size of the source issues list.

<p>Glazed Lists contains an abstract class to extend just for this purpose called
<code>TransformedList</code>. It manages the list methods and has a <code>protected</code>
<code>ListEventAssembler</code>, updates. We will override the <code>get()</code>
method to return an issue's user instead of the issue itself. We must implement
the <code>listChanged()</code> method to respond to changes in our source
issues list. In our <code>listChanged()</code> method we simply forward an 
identical event. This maintains our one-to-one relationship with our source
issues list.

<p><table cellpadding="5" cellspacing="0" width="100%" border="1" bgcolor="#EEEEEE"><tr><td><pre><code>// glazed lists
import ca.odell.glazedlists.*;
<font color="#FF3333">import ca.odell.glazedlists.event.*;</font>

/**
 * An IssuesToUserList is a list of users that is obtained by getting
 * the users from an issues list.
 * 
 * @author &lt;a href="mailto:jesse@odel.on.ca"&gt;Jesse Wilson&lt;/a&gt;
 */
public class IssuesToUserList <font color="#FF3333">extends TransformedList</font> {
    
    /**
     * Construct an IssuesToUserList from an EventList that contains only 
     * Issue objects.
     */
    public IssuesToUserList(EventList source) {
        <font color="#FF3333">super(source);</font>
        <font color="#FF3333">source.addListEventListener(this);</font>
    }
    
    /**
     * Gets the user at the specified index.
     */
    <font color="#FF3333">public Object get(int index) {</font>
        Issue issue = (Issue)source.get(index);
        return issue.getAssignedTo();
    <font color="#FF3333">}</font>
    
    /**
     * When the source issues list changes, propogate the exact same changes
     * for the users list.
     */
    <font color="#FF3333">public void listChanged(ListEvent listChanges) {</font>
        updates.beginEvent();
        while(listChanges.next()) {
            updates.addChange(listChanges.getType(), listChanges.getIndex());
        }
        updates.commitEvent();
    <font color="#FF3333">}</font>
}</code></pre></td></tr></table>

<h3>Eliminating duplicates with UniqueList</h3>

<p>Although our issues list contains dozens issues, there are only a
handful of users and each user is responsible for multiple issues.
This means that our users list will contain duplicates. This problem
is solved quickly and easily by <code>UniqueList</code>. Just like
<code>SortedList</code>, the <code>UniqueList</code> uses <code>Comparable</code>
elements or a <code>Comparator</code> to distinguish between elements. 

<p><table cellpadding="5" cellspacing="0" width="100%" border="1" bgcolor="#EEEEEE"><tr><td><pre><code>    // create an event list to host the issues
    EventList issuesEventList = new BasicEventList();
    <font color="#FF3333">EventList usersEventListNonUnique = new IssuesToUserList(issuesEventList);</font>
    <font color="#FF3333">EventList usersEventList = new UniqueList(usersEventListNonUnique);</font></code></pre></td></tr></table>

<p>Finally we add a <code>JList</code> to our user interface to display the
list of users. In the next part of the tutorial, we will get this widget
to act as a custom filter for the issues table.  

<p><table cellpadding="5" cellspacing="0" width="100%" border="1" bgcolor="#EEEEEE"><tr><td><pre><code>    public void display() {
        // create a panel with a table
        JPanel panel = new JPanel();
        panel.setLayout(new GridBagLayout());
        SortedList issuesSortedList = new SortedList(issuesEventList);
        TextFilterList issuesTextFiltered = new TextFilterList(issuesSortedList);
        EventTableModel issuesTableModel = new EventTableModel(issuesTextFiltered, new IssueTableFormat());
        JTable issuesJTable = new JTable(issuesTableModel);
        TableComparatorChooser tableSorter = new TableComparatorChooser(issuesJTable, issuesSortedList, true);
        JScrollPane issuesTableScrollPane = new JScrollPane(issuesJTable);
        <font color="#FF3333">EventListModel usersListModel = new EventListModel(usersEventList);</font>
        <font color="#FF3333">JList usersJList = new JList(usersListModel);</font>
        JScrollPane usersListScrollPane = new JScrollPane(usersJList);  
        panel.add(usersListScrollPane, new GridBagConstraints(...));
        panel.add(issuesTableScrollPane, new GridBagConstraints(...));
        panel.add(new JLabel("Filter: "), new GridBagConstraints(...));
        panel.add(issuesTextFiltered.getFilterEdit(), new GridBagConstraints(...));
        
        // create a frame with that panel
        JFrame frame = new JFrame("Issues");
        frame.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);
        frame.setSize(540, 380);
        frame.getContentPane().add(panel);
        frame.show();
    }</code></pre></td></tr></table>


<p><img src="screenshot.png" width="540" height="380" alt="Issues Browser">

<h3>So What?</h3>
<p>We have created a list of users that is derived from a list of issues. We
then performed a transformation on the derived user list to create a third list
whose elements are unique. We have shown an example of how chaining list
transformations is an easy way to create a sophisticated user interface.


</div>
</body>
</html>
