<html>
<head><title>Glazed Lists Tutorial Part 2 - Sorting, Tables &amp; Sorting Tables</title>
</head>
<body>
<div class="app">

<h3>Glazed Lists Tutorial</h3>
<h1>Part 2 - Sorting, Tables &amp; Sorting Tables</h1>

<p>In part two of this tutorial we apply a sorted transformation to our
issues list. We construct a JTable to display the list with a column for each
important attribute of our issue class. Finally we add support to sort our JTable
by the clicking on its column headers. 


<h3>SortedList, a transformed list</h3>

<p>The <code>SortedList</code> is simply a wrapper that shows another <code>EventList</code>
in sorted order. Like all <code>TransformedList</code>s, the <code>SortedList</code>
listens for changes to its source list and adjusts itself when changes are made. 
By layering <code>TransformedList</code>s like <code>SortedList</code> and
<code>AbstractFilterList</code>, we are able to create flexible and
powerful programs easily.


<h3>Comparators, Comparable and SortedList</h3>

<p>In order to do sorting in Java, we must be able to do comparisons
with either a <a href="http://java.sun.com/j2se/1.4.2/docs/api/java/util/Comparator.html"><code>Comparator</code></a>
utility class or with elements that implement the 
<a href="http://java.sun.com/j2se/1.4.2/docs/api/java/lang/Comparable.html"><code>Comparable</code></a>
interface. By writing <code>Comparator</code>s (or implementing <code>Comparable</code>),
we gain full control of the sort order of our elements.

<p>In our Issue class, we have decided to sort using the ID field as the only criteria.

<p><table cellpadding="5" cellspacing="0" width="100%" border="1" bgcolor="#EEEEEE"><tr><td><pre><code>public class Issue <font color="#FF3333">implements Comparable</font> {
...
    /**
     * Compares two issues by ID. 
     */
    <font color="#FF3333">public int compareTo(Object other) {</font>
        if(other == null) return -1;
        Issue otherIssue = (Issue)other;
        return id.compareTo(otherIssue.id);
    <font color="#FF3333">}</font>
...
}</code></pre></td></tr></table>

<p>Now that the <code>SortedList</code> can compare elements, we can simply
create a <code>SortedList</code> using the source list as the constructor argument.
The <code>SortedList</code> will provide a sorted view of the original list even
as the original list is modified.

<p><table cellpadding="5" cellspacing="0" width="100%" border="1" bgcolor="#EEEEEE"><tr><td><pre><code>        <font color="#FF3333">SortedList issuesSortedList = new SortedList(issuesEventList);</font></code></pre></td></tr></table>

<h3>Using TableFormat to specify columns</h3>

<p>Although the <code>EventTableModel</code> will take care of managing the
table rows, it is still necessary to do some set up. We need to specify column
names and how to get the value for a particular column. To do this
we implement the <code>TableFormat</code> interface.

<p><table cellpadding="5" cellspacing="0" width="100%" border="1" bgcolor="#EEEEEE"><tr><td><pre><code>public class IssueTableFormat <font color="#FF3333">implements TableFormat</font> {
    
    <font color="#FF3333">public int getColumnCount() {</font>
        return 6;
    <font color="#FF3333">}</font>
    
    <font color="#FF3333">public String getColumnName(int column) {</font>
        if(column == 0) {
            return "ID";
        } else if(column == 1) {
            return "Type";
        } else if(column == 2) {
            return "Priority";
        } else if(column == 3) {
            return "State";
        } else if(column == 4) {
            return "Result";
        } else if(column == 5) {
            return "Summary";
        }
        return null;
    <font color="#FF3333">}</font>
    
    <font color="#FF3333">public Object getColumnValue(Object baseObject, int column) {</font>
        if(baseObject == null) return null;
        Issue issue = (Issue)baseObject;
        if(column == 0) {
            return issue.getId();
        } else if(column == 1) {
            return issue.getIssueType();
        } else if(column == 2) {
            return issue.getPriority();
        } else if(column == 3) {
            return issue.getStatus();
        } else if(column == 4) {
            return issue.getResolution();
        } else if(column == 5) {
            return issue.getShortDescription();
        }
        return null;
    <font color="#FF3333">}</font>
}</code></pre></td></tr></table>

<h3>The EventTableModel and TableComparatorChooser</h3>

<p>Now that we have our columns prepared, we can replace our <code>JList</code> in
part one with a more sophisticated <code>JTable</code>. We simply replace the
<code>EventListModel</code> with an <code>EventTableModel</code>, which takes our
<code>IssueTableFormat</code> in its constructor. We use our sorted list as the
source list for our new <code>EventTableModel</code>, which shows the issues sorted
by event ID.

<p>Although our table will be sorted by event ID, we would like our users to be
able to choose a different sorting criteria by clicking on the column headers.
For example, clicking on the "Type" header should sort our issues by type.
Glazed Lists includes a utility class for just this purpose called
<code>TableComparatorChooser</code>. The <code>TableComparatorChooser</code> is
flexible and allows us to specify zero or more <code>Comparator</code>s for each
column. As the user clicks on a column's header, they cycle through the list
of <code>Comparator</code>s for that column. You must also specify whether it shall
use simple single-column sorting or more powerful multiple-column sorting. The
<code>TableComparatorChooser</code> automatically includes a <code>Comparator</code>
for each column that sorts using the <code>Comparable</code> interface for that
column's value. If your column's value is not <code>Comparable</code>, you 
<strong>must</strong> remove the default <code>Comparator</code> using 
<code>TableComparatorChooser.getComparatorsForColumn(column).clear()</code>. 

<p><table cellpadding="5" cellspacing="0" width="100%" border="1" bgcolor="#EEEEEE"><tr><td><pre><code>    public void display() {
        // create a panel with a table
        JPanel panel = new JPanel();
        panel.setLayout(new GridBagLayout());
        <font color="#FF3333">SortedList issuesSortedList = new SortedList(issuesEventList);</font>
        <font color="#FF3333">EventTableModel issuesTableModel = new EventTableModel(issuesSortedList, new IssueTableFormat());</font>
        <font color="#FF3333">JTable issuesJTable = new JTable(issuesTableModel);</font>
        <font color="#FF3333">TableComparatorChooser tableSorter = new TableComparatorChooser(issuesJTable, issuesSortedList, true);</font>
        JScrollPane issuesTableScrollPane = new JScrollPane(issuesJTable);
        panel.add(issuesTableScrollPane, new GridBagConstraints(...));
        
        // create a frame with that panel
        JFrame frame = new JFrame("Issues");
        frame.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);
        frame.setSize(540, 380);
        frame.getContentPane().add(panel);
        frame.show();
    }</code></pre></td></tr></table>


<p><img src="screenshot.png" width="540" height="380" alt="Issues Browser">

<h3>So What?</h3>
<p>We have constructed a <code>JTable</code> with a simple and elegant API.



</div>
</body>
</html>
