<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.1.2//EN"
    "http://www.oasis-open.org/docbook/xml/4.1.2/docbookx.dtd">
<book>
  <bookinfo>
    <title>Glazed Lists Tutorial</title>
      
    <author>
      <firstname>Jesse</firstname>        
      <surname>Wilson</surname>
    </author>
      
    <copyright>
      <year>2003</year>
      <holder>Jesse Wilson</holder>
    </copyright>
  </bookinfo>
    
    
  <chapter>
    <title>Basics</title>
      
    <para>In this tutorial we are going to build a program for browsing a list of issues. We
        will demonstrate the features of Glazed Lists in this program and provide the source
        code to use these features. In part one of this tutorial we discuss Glazed Lists and
        build a simple application that displays our list of issues within a 
        <classname>JList</classname>.</para>
      
    <section>
      <title>EventList, like ArrayList or Vector</title>
        
      <para>The <classname>EventList</classname> interface extends the
          familiar<classname>java.util.List</classname> interface. This means it has the
          same<function>add()</function>, <function>set()</function> and
          <function>remove()</function> methods found in <classname>ArrayList</classname>
          and <classname>Vector</classname>.</para>
        
      <para>But there are some differences between <classname>EventList</classname>s and the
          plain <classname>java.util.List</classname>:</para>
            
      <itemizedlist>
        <listitem>
          <para><emphasis>Event listeners</emphasis>: In order to propagate changes from a
              source list to its various display widgets and transformations,</para>
        </listitem>          

        <classname>EventList</classname>s fire events when modified.

        <listitem>
          <para><emphasis>Concurrency</emphasis>: <classname>EventList</classname>s may be
              accessed by multiple threads simultaneously so they provide easy-to-use and
              powerful locks.</para>
        </listitem>
      </itemizedlist>
    </section>

    <section>
      <title>JList, JComboBox and JTable: Widgets with models</title>
        
      <para>Swing is a user interface toolkit that uses the Model-View-Controller design
          pattern throughout. This allows a Swing developer to focus on the data in a
          component independent of how that data is displayed.</para>
            
      <para>With Glazed Lists, the <classname>EventListModel</classname> class provides
          a<classname>ListModel</classname> to populate a JList widget from any
          <classname>EventList</classname>. Then as you <function>add()</function> and
          <function>remove()</function> on your<classname>EventList</classname>, the JList
          widget responds automatically. Similarly the <classname>EventTableModel</classname>
          will populate a <classname>JTable</classname> and
          the<classname>EventComboBoxModel</classname> will populate a 
          <classname>JComboBox</classname>.</para>
    </section>
      
    <section>
      <title>A simple issue browser</title>
        
      <para>We use Glazed Lists to display our issue list in a few simple steps. We create a
          <classname>BasicEventList</classname> and populate it with a
          <classname>Collection</classname> of issues. Then we create a
          <classname>EventListModel</classname> and specify that as the model for our
          <classname>JList</classname> widget. Finally we display it all on screen.</para>
            
      <informalexample>
        <programlisting linenumbering="numbered">
import java.util.*;
import java.io.*;
import java.net.*;
import javax.swing.*;
import java.awt.GridBagLayout;
import java.awt.GridBagConstraints;
import java.awt.Insets;
// glazed lists
import ca.odell.glazedlists.*;
import ca.odell.glazedlists.swing.*;

/**
 * An IssueBrowser is a program for finding and viewing issues.
 * 
 * @author Jesse Wilson
 */
public class IssuesBrowser {
    
    // create an event list to host the issues
    <emphasis>EventList issuesEventList = new BasicEventList();</emphasis>
    
    /**
     * Load the issues from the specified URL.
     */
    public void load(String issuesUrl) {
        try {
            InputStream issuesIn = new URL(issuesUrl).openConnection().getInputStream();
            Collection sourceIssues = Issue.parseIssuezillaXML(issuesIn);
            <emphasis>issuesEventList.addAll(sourceIssues);</emphasis>
        } catch(IOException e) {
            e.printStackTrace();
        }
    }
    
    /**
     * Display a frame for browsing issues.
     */
    public void display() {
        // create a panel with a table
        JPanel panel = new JPanel();
        panel.setLayout(new GridBagLayout());
        <emphasis>EventListModel issuesListModel = new EventListModel(issuesEventList);</emphasis>
        <emphasis>JList issuesJList = new JList(issuesListModel);</emphasis>
        JScrollPane issuesListScrollPane = new JScrollPane(issuesJList);
        panel.add(issuesListScrollPane, new GridBagConstraints(...));
        
        // create a frame with that panel
        JFrame frame = new JFrame("Issues");
        frame.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);
        frame.setSize(540, 380);
        frame.getContentPane().add(panel);
        frame.show();
    }
    
    public static void main(String[] args) {
        if(args.length != 1) {
            System.out.println("Usage: IssueBrowser &lt;issues url&gt;");
            return;
        }

        // load the issues and display the browser
        String issuesUrl = args[0];
        IssuesBrowser browser = new IssuesBrowser();
        browser.load(issuesUrl);
        browser.display();
    }
}
        </programlisting>
      </informalexample>
    </section>
      
    <screenshot>
      <graphic fileref="basics/screenshot.png">
        <alt>Issues Browser</alt>
      </graphic>
    </screenshot>
      
    <section>
      <title>So What?</title>
        
      <para>So far we haven't taken advantage of the advanced features of Glazed Lists. But
          with this simple framework in place we can easily add filtering and sorting to the
          list. We can make changes to the display widget simply by making changes to its
          source list. Should we decide to display our issues in a different widget such as
          a<classname>JTable</classname> or <classname>JComboBox</classname>, that is now easy
          as well.</para>
    </section>
  </chapter>
    
    
  <chapter>
    <title>Sorting, Tables &amp; Sorting Tables</title>
      
    <para>In part two of this tutorial we apply a sorted transformation to our issues list. We
        construct a <classname>JTable</classname> to display the list with a column for each 
        important attribute of the <classname>Issue</classname> class. Finally we add support 
        to sort our <classname>JTable</classname> by the clicking on its column headers.</para>
      
    <section>
      <title>SortedList, a transformed list</title>
        
      <para>The <classname>SortedList</classname> is simply a wrapper that shows another 
          <classname>EventList</classname> in sorted order. Like all 
          <classname>TransformedList</classname>s, the <classname>SortedList</classname> listens
          for changes to its source list and adjusts itself when changes are made. By layering
          <classname>TransformedList</classname>s like <classname>SortedList</classname> and 
          <classname>AbstractFilterList</classname>, we are able to create flexible and powerful
          programs easily.</para>
    </section>
      
    <section>
      <title>Comparators, Comparable and SortedList</title>
        
      <para>In order to do sorting in Java, we must be able to do comparisons with either a 
          <ulink url="http://java.sun.com/j2se/1.4.2/docs/api/java/util/Comparator.html">
          <classname>Comparator</classname></ulink> utility class or with elements that 
          implement the <ulink url="http://java.sun.com/j2se/1.4.2/docs/api/java/lang/Comparable.html">
          <classname>Comparable</classname></ulink> interface. By writing 
          <classname>Comparator</classname>s (or implementing <classname>Comparable</classname>),
          we gain full control of the sort order of our elements.</para>
        
      <para>In our <classname>Issue</classname> class, we have decided to sort using the ID field
          as the only criteria.</para>
        
      <informalexample>
        <programlisting linenumbering="numbered">
public class Issue implements Comparable {
...
    /**
     * Compares two issues by ID. 
     */
    public int compareTo(Object other) {
        if(other == null) return -1;
        Issue otherIssue = (Issue)other;
        return id.compareTo(otherIssue.id);
    }
...
}
        </programlisting>
      </informalexample>
        
      <para>Now that the <classname>SortedList</classname> can compare elements, we can simply
          create a <classname>SortedList</classname> using the source list as the constructor 
          argument. The <classname>SortedList</classname> will provide a sorted view of the 
          original list even as the original list is modified.</para>
        
      <informalexample>
        <programlisting linenumbering="numbered">
SortedList issuesSortedList = new SortedList(issuesEventList);
        </programlisting>
      </informalexample>
    </section>
      
    <section>
      <title>Using TableFormat to specify columns</title>
        
      <para>Although the <classname>EventTableModel</classname> will take care of managing the
          table rows, it is still necessary to do some set up. We need to specify column names
          and how to get the value for a particular column. To do this we implement the 
          <classname>TableFormat</classname> interface.</para>
        
      <informalexample>
        <programlisting linenumbering="numbered">
public class IssueTableFormat implements TableFormat {
    
    public int getColumnCount() {
        return 6;
    }
    
    public String getColumnName(int column) {
        if(column == 0) {
            return "ID";
        } else if(column == 1) {
            return "Type";
        } else if(column == 2) {
            return "Priority";
        } else if(column == 3) {
            return "State";
        } else if(column == 4) {
            return "Result";
        } else if(column == 5) {
            return "Summary";
        }
        return null;
    }
    
    public Object getColumnValue(Object baseObject, int column) {
        if(baseObject == null) return null;
        Issue issue = (Issue)baseObject;
        if(column == 0) {
            return issue.getId();
        } else if(column == 1) {
            return issue.getIssueType();
        } else if(column == 2) {
            return issue.getPriority();
        } else if(column == 3) {
            return issue.getStatus();
        } else if(column == 4) {
            return issue.getResolution();
        } else if(column == 5) {
            return issue.getShortDescription();
        }
        return null;
    }
}          
        </programlisting>
      </informalexample>
    </section>
      
    <section>
      <title>The EventTableModel and TableComparatorChooser</title>
        
      <para>Now that we have our columns prepared, we can replace our <classname>JList</classname>
          in part one with a more sophisticated <classname>JTable</classname>. We simply replace
          the <classname>EventListModel</classname> with an <classname>EventTableModel</classname>,
          which takes our <classname>IssueTableFormat</classname> in its constructor. We use our
          sorted list as the source list for our new <classname>EventTableModel</classname>, which
          shows the issues sorted by event ID.</para>
        
      <para>Although our table will be sorted by event ID, we would like our users to be able to
          choose a different sorting criteria by clicking on the column headers. For example, 
          clicking on the "Type" header should sort our issues by type. Glazed Lists includes a
          utility class for just this purpose called <classname>TableComparatorChooser</classname>.
          The <classname>TableComparatorChooser</classname> is flexible and allows us to specify
          zero or more <classname>Comparator</classname>s for each column. As the user clicks on
          a column's header, they cycle through the list of <classname>Comparator</classname>s for
          that column. You must also specify whether it shall use simple single-column sorting or
          more powerful multiple-column sorting. The <classname>TableComparatorChooser</classname>
          automatically includes a <classname>Comparator</classname> for each column that sorts 
          using the <classname>Comparable</classname> interface for that column's value. If your
          column's value is not <classname>Comparable</classname>, you must remove the default 
          <classname>Comparator</classname> using 
          <function>TableComparatorChooser.getComparatorsForColumn(column).clear()</function>.</para>
        
      <informalexample>
        <programlisting linenumbering="numbered">
    public void display() {
        // create a panel with a table
        JPanel panel = new JPanel();
        panel.setLayout(new GridBagLayout());
        SortedList issuesSortedList = new SortedList(issuesEventList);
        EventTableModel issuesTableModel = new EventTableModel(issuesSortedList, new IssueTableFormat());
        JTable issuesJTable = new JTable(issuesTableModel);
        TableComparatorChooser tableSorter = new TableComparatorChooser(issuesJTable, issuesSortedList, true);
        JScrollPane issuesTableScrollPane = new JScrollPane(issuesJTable);
        panel.add(issuesTableScrollPane, new GridBagConstraints(...));
        
        // create a frame with that panel
        JFrame frame = new JFrame("Issues");
        frame.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);
        frame.setSize(540, 380);
        frame.getContentPane().add(panel);
        frame.show();
    }          
        </programlisting>
      </informalexample>
    </section>
      
    <screenshot>
      <graphic fileref="sorting/screenshot.png">
        <alt>Issues Browser</alt>
      </graphic>
    </screenshot>
      
    <section>
      <title>So What?</title>
        
      <para>We have constructed a <classname>JTable</classname> with a simple and elegant 
          API.</para>
    </section>            
  </chapter>
    
    
  <chapter>
    <title>Text Filtering</title>
      
    <para>In part three of this tutorial we add a widget to filter the list of issues. This
        widget is a simple <classname>JTextField</classname> and is inspired by a similar
        widget found in <ulink url="http://www.apple.com/">Apple iTunes</ulink>. As the user
        types text into the field, only rows that contain that text are shown. This is a fast
        and easy way to find a needle in a haystack!</para>
          
    <section>
      <title>TextFilterList, TextFilterable and TextFilterator</title>
        
      <para>To add filtering to our issues browser, we first need to access the filter text
          for each list element. We can do this by implementing either the 
          <classname>TextFilterable</classname> interface or the 
          <classname>TextFilterator</classname> interface. <classname>TextFilterable</classname>
          requires the filtered objects to include the method <function>getFilterStrings()</function>.
          Alternatively, the <classname>Filterator</classname> interface can be used to externally
          specify filter strings. For our issues browser, we will implement 
          <function>getFilterStrings()</function> in our <classname>Issue</classname> class.</para>        
      
      <informalexample>
        <programlisting linenumbering="numbered">
public class Issue implements TextFilterable, Comparable {
...
    /**
     * Gets the strings to filter this issue by.
     */
    public String[] getFilterStrings() {
        return new String[] {
            status, priority, resolution, component, version, repPlatform,
            assignedTo, subcomponent, reporter, targetMilestone, issueType,
            qaContact, statusWhiteboard, operatingSystem, shortDescription
        };
    }
...
}        
        </programlisting>
      </informalexample>
    </section>

    <section>
      <title>Adding the TextFilterList and its filter widget</title>
        
      <para>Just as we have transformed our source list to be sorted, we will transform the
          sorted list to be filtered. The <classname>JTable</classname> will display the 
          filtered list which is already sorted. We will also add the filter editing 
          <classname>JTextField</classname> to our panel.</para>
      
      <informalexample>
        <programlisting linenumbering="numbered">
    public void display() {
        // create a panel with a table
        JPanel panel = new JPanel();
        panel.setLayout(new GridBagLayout());
        SortedList issuesSortedList = new SortedList(issuesEventList);
        TextFilterList issuesTextFiltered = new TextFilterList(issuesSortedList);
        EventTableModel issuesTableModel = new EventTableModel(issuesTextFiltered, new IssueTableFormat());
        JTable issuesJTable = new JTable(issuesTableModel);
        TableComparatorChooser tableSorter = new TableComparatorChooser(issuesJTable, issuesSortedList, true);
        JScrollPane issuesTableScrollPane = new JScrollPane(issuesJTable);
        panel.add(issuesTableScrollPane, new GridBagConstraints(...));
        panel.add(new JLabel("Filter: "), new GridBagConstraints(...));
        panel.add(issuesTextFiltered.getFilterEdit(), new GridBagConstraints(...));
        
        // create a frame with that panel
        JFrame frame = new JFrame("Issues");
        frame.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);
        frame.setSize(540, 380);
        frame.getContentPane().add(panel);
        frame.show();
    }        
        </programlisting>
      </informalexample>
    </section>
      
    <screenshot>
      <graphic fileref="textfiltering/screenshot.png">
        <alt>Issues Browser</alt>
      </graphic>
    </screenshot>
      
    <section>
      <title>So What?</title>
        
      <para>We have added filtering to our issue browser without having to be concerned with
          sorting, display or changes to the source list.</para>
    </section>            
  </chapter>
    
    
  <chapter>
    <title>TransformedList and UniqueList</title>
      
    <para>In part four of this tutorial, we compose a list of users derived from the list of
        issues. Each issue has a user, so we extract all users from all issues to form a new
        list. The derived list is also a <classname>EventList</classname> so we can apply
        filtering and sorting to it in turn. In part five we use our derived users list to
        filter for issues belonging to a selected user.</para>
      
    <section>
      <title>ListEvents and ListEventAssembler</title>
        
      <para>Earlier in the tutorial we discussed how Glazed Lists uses events to propagate 
          changes to <classname>TransformedLists</classname> and widgets. Although this had
          been significant in understanding how <classname>EventList</classname>s work, it
          was not necessary to interact with the event and listener code directly. In this
          stage we create a custom transformation and require some of the event and listener
          code in the process.</para>
        
      <para><classname>ListEvent</classname>s are sophisticated event objects. Each event 
          notification may contain information on hundreds of inserts, updates and deletes
          within a list. To simplify the process, the <classname>ListEventAssembler</classname>
          class assembles and manages <classname>ListEvent</classname>s and their listeners.
          The <classname>ListEventAssembler</classname> has methods <function>addInsert(index)</function>,
          <function>addUpdate(index)</function> and <function>addDelete(index)</function> to
          be called with each list <function>add()</function>, <function>set()</function> and
          <function>remove()</function>, respectively. Finally it has a pair of methods
          <function>beginEvent()</function> and <function>commitEvent()</function> that prepare
          for and fire the event to listeners.</para>    
    </section>
      
    <section>
      <title>TransformedList and ListEvents</title>
        
      <para>Fortunately, we only need to create simple <classname>ListEvent</classname>s. 
          Our goal is to create a list containing the users for each issue. For example, if
          the first element of our issue list contained an <classname>Issue</classname> object
          that belonged to user "jessewilson", then the first element of our users list will
          simply contain the element "jessewilson". The size of our users list will be
          exactly the same size of the source issues list.</para>
        
      <para>Glazed Lists contains an abstract class to extend for just this purpose called
          <classname>TransformedList</classname>. It manages the list methods and has a 
          protected <classname>ListEventAssembler</classname>, updates. We will override the
          <function>get()</function> method to return an issue's user instead of the issue itself.
          We must implement the <function>listChanged()</function> method to respond to changes
          in our source issues list. In our <function>listChanged()</function> method we simply
          forward an identical event. This maintains our one-to-one relationship with our source
          issues list.</para>
        
      <informalexample>
        <programlisting linenumbering="numbered">
// glazed lists
import ca.odell.glazedlists.*;
import ca.odell.glazedlists.event.*;

/**
 * An IssuesToUserList is a list of users that is obtained by getting
 * the users from an issues list.
 * 
 * @author Jesse Wilson
 */
public class IssuesToUserList extends TransformedList {
    
    /**
     * Construct an IssuesToUserList from an EventList that contains only 
     * Issue objects.
     */
    public IssuesToUserList(EventList source) {
        super(source);
        source.addListEventListener(this);
    }
    
    /**
     * Gets the user at the specified index.
     */
    public Object get(int index) {
        Issue issue = (Issue)source.get(index);
        return issue.getAssignedTo();
    }
    
    /**
     * When the source issues list changes, propogate the exact same changes
     * for the users list.
     */
    public void listChanged(ListEvent listChanges) {
        updates.beginEvent();
        while(listChanges.next()) {
            updates.addChange(listChanges.getType(), listChanges.getIndex());
        }
        updates.commitEvent();
    }
}          
        </programlisting>
      </informalexample>
    </section>
      
    <section>
      <title>Eliminating duplicates with UniqueList</title>
        
      <para>Although our issues list contains over 100 issues, there are only a handful of
          users and each user is responsible for multiple issues. This means that our users
          list will contain duplicates. This problem is solved quickly and easily by 
          <classname>UniqueList</classname>. Just like <classname>SortedList</classname>, the
          <classname>UniqueList</classname> uses <classname>Comparable</classname> elements
          or a <classname>Comparator</classname> to distinguish between elements.</para>
        
      <informalexample>
        <programlisting linenumbering="numbered">
    // create an event list to host the issues
    EventList issuesEventList = new BasicEventList();
    EventList usersEventListNonUnique = new IssuesToUserList(issuesEventList);
    EventList usersEventList = new UniqueList(usersEventListNonUnique);
          
        </programlisting>
      </informalexample>
        
      <para>Finally we add a <classname>JList</classname> to our user interface to display the
          list of users. In the next part of the tutorial, we will get this widget to act as a
          custom filter for the issues table.</para>
        
      <informalexample>
        <programlisting linenumbering="numbered">
    public void display() {
        // create a panel with a table
        JPanel panel = new JPanel();
        panel.setLayout(new GridBagLayout());
        SortedList issuesSortedList = new SortedList(issuesEventList);
        TextFilterList issuesTextFiltered = new TextFilterList(issuesSortedList);
        EventTableModel issuesTableModel = new EventTableModel(issuesTextFiltered, new IssueTableFormat());
        JTable issuesJTable = new JTable(issuesTableModel);
        TableComparatorChooser tableSorter = new TableComparatorChooser(issuesJTable, issuesSortedList, true);
        JScrollPane issuesTableScrollPane = new JScrollPane(issuesJTable);
        EventListModel usersListModel = new EventListModel(usersEventList);
        JList usersJList = new JList(usersListModel);
        JScrollPane usersListScrollPane = new JScrollPane(usersJList);  
        panel.add(usersListScrollPane, new GridBagConstraints(...));
        panel.add(issuesTableScrollPane, new GridBagConstraints(...));
        panel.add(new JLabel("Filter: "), new GridBagConstraints(...));
        panel.add(issuesTextFiltered.getFilterEdit(), new GridBagConstraints(...));
        
        // create a frame with that panel
        JFrame frame = new JFrame("Issues");
        frame.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);
        frame.setSize(540, 380);
        frame.getContentPane().add(panel);
        frame.show();
    }          
        </programlisting>
      </informalexample>        
      
    </section>      
      
    <screenshot>
      <graphic fileref="unique/screenshot.png">
        <alt>Issues Browser</alt>
      </graphic>
    </screenshot>
      
    <section>
      <title>So What?</title>
        
      <para>We have created a list of users that is derived from a list of issues. We then 
          performed a transformation on the derived user list to create a third list whose
          elements are unique. We have shown an example of how chaining list transformations
          is an easy way to create a sophisticated user interface.</para>
    </section>
  </chapter>
        
  <chapter>
    <title>EventSelectionModel and Custom Filter Lists</title>
      
    <para>In part five we are transforming the user list that we built in part four into a
        filter for the issues list. When a user is selected, only issues for that user 
        shall be displayed.</para>
      
    <section>
      <title>EventSelectionModel</title>
        
      <para>Just as Glazed Lists provides models for lists, combo boxes and tables, it 
          provides a model for list selection. The <classname>EventSelectionModel</classname>
          provides two advantages over the standard 
          <classname>DefaultListSelectionModel</classname>.</para>
        
      <itemizedlist>
        <listitem>
          <para>It provides its own <classname>EventList</classname> which contains the widget's
              current selection. You can now access the selected elements like they are the 
              elements of an <classname>ArrayList</classname> or 
              <classname>Vector</classname>.</para>
        </listitem>
          
        <listitem>
          <para>It provides a fourth selection mode in addition to the standard modes of single,
              single range and multiple range selection. With 
              <classname>MULTIPLE_INTERVAL_SELECTION</classname>, when a row is inserted within
              a selected range, the inserted row becomes selected. This can be annoying when
              unfiltering because restored elements may become selected. This problem is solved
              by <classname>EventSelectionModel</classname>'s default 
              <classname>MULTIPLE_INTERVAL_SELECTION_DEFENSIVE</classname> mode, which does not
              add inserted elements to the selection.</para>
        </listitem>        
      </itemizedlist>
        
      <para>When implementing filtering we display an issue only if there are no users selected
          or if that issue's user is among those selected. This is easy by using the 
          <function>isEmpty()</function> and <function>contains()</function> methods of the 
          selection list.</para>
        
      <informalexample>
        <programlisting linenumbering="numbered">
            if(usersSelectedList.isEmpty()) return true;
            ...
            String user = issue.getAssignedTo();
            return usersSelectedList.contains(user);          
        </programlisting>
      </informalexample>
    </section>
      
    <section>
      <title>Custom filters using AbstractFilterList</title>
        
      <para>Just as we filtered issues for text using <classname>TextFilterList</classname>,
          we can filter with arbitrary criteria by creating our own filter list. The 
          <classname>AbstractFilterList</classname> is designed for just that. To implement
          a custom filter list, we need to do a few things:</para>
        
      <itemizedlist>
        <listitem>
          <para>Extend <classname>AbstractFilterList</classname> and call 
              <function>handleFilterChanged()</function> within the constructor.</para>
        </listitem>
          
        <listitem>
          <para>Implement the <function>filterMatches(Object)</function> method as a test
              whether an element should be included or not.</para>
        </listitem>
          
        <listitem>
          <para>Call <function>handleFilterChanged()</function> whenever the filter criteria
              has changed in order to re-apply the filter.</para>
        </listitem>
      </itemizedlist>
        
      <para>We implemented our user filter using <classname>AbstractFilterList</classname>.
          The class re-applies the filter whenever the user list selection changes. It uses
          a <classname>EventSelectionModel</classname> to simplify filter testing code.</para>
        
      <para>The <classname>EventSelectionModel</classname> is accessed by both the Swing event
          dispatch thread and the list updating threads so we must ensure that access to it is
          thread safe. Therefore we wrap our calls to the selection model in a try/finally block
          where we can acquire a read lock. This is more information on thread safety in the
          next part of this tutorial.</para>
        
      <informalexample>
        <programlisting linenumbering="numbered">
import java.util.*;
import java.io.*;
import java.net.*;
import javax.swing.*;
import javax.swing.event.*;
// glazed lists
import ca.odell.glazedlists.*;
import ca.odell.glazedlists.swing.*;

/**
 * An IssuesUserFilter is a filter list that filters based on the selected
 * users.
 * 
 * @author Jesse Wilson
 */
public class IssuesUserFilter extends AbstractFilterList implements ListSelectionListener {
    
    /** a list of users */
    EventList usersEventList;
    EventList usersSelectedList;
    /** a widget for selecting users */
    JList userSelect;
    
    /**
     * Create a filter list that filters the specified source list, which
     * must contain only Issue objects.
     */
    public IssuesUserFilter(EventList source) {
        super(source);
        
        // create a unique users list from the source issues list
        usersEventList = new UniqueList(new IssuesToUserList(source));

        // create a JList that contains users
        EventListModel usersListModel = new EventListModel(usersEventList);
        userSelect = new JList(usersListModel);

        // create an EventList containing the JList's selection
        EventSelectionModel userSelectionModel = new EventSelectionModel(usersEventList);
        userSelect.setSelectionModel(userSelectionModel.getListSelectionModel());
        usersSelectedList = userSelectionModel.getEventList();
        userSelect.addListSelectionListener(this);

        handleFilterChanged();
    }
    
    /**
     * Get the widget for selecting users.
     */
    public JList getUserSelect() {
        return userSelect;
    }

    /**
     * When the JList selection changes, refilter.
     */
    public void valueChanged(ListSelectionEvent e) {
        handleFilterChanged();
    }
    
    /**
     * Test whether to include or not include the specified issue based
     * on whether or not their user is selected.
     */
    public boolean filterMatches(Object o) {
        usersSelectedList.getReadWriteLock().readLock().lock();
        try {
            if(o == null) return false;
            if(usersSelectedList.isEmpty()) return true;
            
            Issue issue = (Issue)o;
            String user = issue.getAssignedTo();
            return usersSelectedList.contains(user);
            
        } finally {
            usersSelectedList.getReadWriteLock().readLock().unlock();
        }
    }
}          
        </programlisting>
      </informalexample>      
    </section>
      
    <screenshot>
      <graphic fileref="customfilter/screenshot.png">
        <alt>Issues Browser</alt>
      </graphic>
    </screenshot>
     
    <section>
      <title>So What?</title>
        
      <para>We have exploited some advanced Glazed Lists functionality to build a user filter.
          We used a convenience list from the selection model and previewed the concurrency 
          facilities within Glazed Lists.</para>
    </section>      
  </chapter>
    
    
  <chapter>
    <title>Concurrency</title>
      
    <para>One great feature of Glazed Lists is that data can be updated in the background
        while a user interacts with your user interface. Glazed Lists is designed to be used
        with many threads, each reading or writing their list of choice. In this section we 
        show how to use Glazed Lists concurrently.</para>
          
    <section>
      <title>Read/Write Locks</title>
        
      <para>Every <classname>EventList</classname> has a method 
          <function>getReadWriteLock()</function> that can be used to provide concurrent 
          access to the list. Read/Write locks are designed to allow access for either 
          multiple readers or a single writer. All locks in Glazed Lists are 
          <emphasis>reentrant</emphasis> so that a single thread can 
          <function>lock()</function> multiple times.</para>
            
      <para>To read from a list that is being read or written by a different thread:</para>
                    
      <informalexample>
        <programlisting linenumbering="numbered">
    EventList myList = ...
    myList.getReadWriteLock().readLock().lock();
    try {
        // perform read operations like myList.size() and myList.get()
    } finally {
        myList.getReadWriteLock().readLock().unlock();
    }          
        </programlisting>
      </informalexample>
        
      <para>To write from a list that is being read or written by a different thread:</para>
        
      <informalexample>
        <programlisting linenumbering="numbered">
    EventList myList = ...
    myList.getReadWriteLock().writeLock().lock();
    try {
        // perform write operations like myList.set() and myList.clear()
    } finally {
        myList.getReadWriteLock().writeLock().unlock();
  }      
        </programlisting>
      </informalexample>                
    </section>
      
    <section>
      <title>ThreadSafeList</title>
       
      <para>Glazed Lists provides a convenience class in order to avoid wrapping all of your
          read operations with this try/finally block called <classname>ThreadSafeList</classname>
          Simply wrap your list of interest in a <classname>ThreadSafeList</classname> and perform
          your method calls on that class. Unfortunately, <classname>ThreadSafeList</classname> 
          has some disadvantages: </para>
            
      <itemizedlist>
        <listitem>
          <para>It may be slower because it must perform a <function>lock()</function> and
              <function>unlock</function> for each method call because manual locking allows
              a block of operations to share a lock.</para>
        </listitem>

        <listitem>
          <para>It is possible that the source list will change between two adjacent 
              <classname>ThreadSafeList</classname> calls.</para>
        </listitem>          
      </itemizedlist>      
    </section>
    
    <section>
      <title>The Swing Event Dispatch Thread</title>
        
      <para>Swing is thread-unsafe. But it is completely safe for you to create an 
          <classname>EventTableModel</classname> or <classname>EventListModel</classname> that
          is updated by a non-Swing thread. This is because the 
          <classname>EventTableModel</classname> uses an <classname>EventThreadProxy</classname>,
          which receives updates from any source thread and fires them using the Swing event 
          dispatch thread.</para>
        
      <para>If your code must access the <classname>EventTableModel</classname> or 
          other Swing classes, it should do so only on the Swing event dispatch thread. This is
          easy with the <classname>SwingUtilities</classname>.<function>invokeLater()</function>
          method.</para>
    </section>
      
    <section>
      <title>Multithreading our IssuesBrowser</title>
        
      <para>Adding multithreading support to our <classname>IssuesBrowser</classname> is
          straightforward. We create a <classname>TimerTask</classname> that reads in our issues
          file and populates a list with the result. Then we create a 
          <classname>Timer</classname> and start our custom 
          <classname>TimerTask</classname>.</para>
        
      <informalexample>
        <programlisting linenumbering="numbered">
/**
 * An IssuesList is a list of issues that automatically updates itself.
 * 
 * @author Jesse Wilson
 */
public class IssuesList extends TransformedList {
    
    /** the source of the issues */
    private String issuesUrl;
    
    /** refresh every five minutes */
    private static long ISSUES_REFRESH_INTERVAL = 1000 * 60 * 5; 
    
    /**
     * Create a new IssuesList that shows issues from the specified URL.
     */
    public IssuesList() {
        super(new UniqueList(new BasicEventList()));
        
        // listen to changes and propagate them
        source.addListEventListener(this);
    }
    
    /**
     * Starts the issues list update daemon.
     */
    public void start(String issuesUrl) {
        this.issuesUrl = issuesUrl;
        new Timer().scheduleAtFixedRate(new IssuesRefreshTask(), 0, ISSUES_REFRESH_INTERVAL);
    }
    
    /**
     * A task that updates the issues list.
     */
    class IssuesRefreshTask extends TimerTask {

        /**
         * When run, this fetches the issues from the issues URL and refreshes
         * the issues list.
         */
        public void run() {
            // load the issues
            SortedSet issuesSorted = new TreeSet();
            try {
                InputStream issuesIn = new URL(issuesUrl).openConnection().getInputStream();
                Collection issues = Issue.parseIssuezillaXML(issuesIn);
                issuesSorted.addAll(issues);
            } catch(IOException e) {
                e.printStackTrace();
            }

            // replace the current issues list with the new issues list
            source.getReadWriteLock().writeLock().lock();
            try {
                UniqueList uniqueSource = (UniqueList)source;
                uniqueSource.replaceAll(issuesSorted);
            } finally {
                source.getReadWriteLock().writeLock().unlock();
            }
        }
    }

    /**
     * When the source issues list changes, propogate the exact same changes.
     */
    public void listChanged(ListEvent listChanges) {
        // just pass on the changes
        updates.forwardEvent(listChanges);
    }
}        
        </programlisting>
      </informalexample>
        
      <para>Note that <classname>IssuesList</classname> uses a <classname>UniqueList</classname>
          as its source list. This is because <classname>UniqueList</classname> provides a
          convenience method <function>replaceAll()</function> for lists that poll an external
          source for their contents. The <function>replaceAll()</function> is similar to calling
          <function>clear()</function> followed by <function>addAll()</function> with one major 
          difference. The <function>replaceAll()</function>, method allows your list to be 
          updated without causing your table's selection to be lost.</para>        
    </section>                
    
    <screenshot>
      <graphic fileref="threading/screenshot.png">
        <alt>Issues Browser</alt>
      </graphic>
    </screenshot>
      
    <section>
      <title>So What?</title>
        
      <para>We have examined the concurrency support in Glazed Lists. We have modified our 
          <classname>IssuesBrowser</classname> to continuously update our data in the background.
          And although our data is continuously being updated, we never lose our table's selection.</para>
    </section>            
  </chapter>
    
    
  <chapter>
    <title>ThresholdList</title>
      
    <para>In part seven we are adding another kind of filtering to the issue list.  This filter
        will allow a user to display the full range of issue priorities or focus in on only
        the most important issues.  The list filtering will be driven by a slider widget.</para>
      
    <section>
      <title>ThresholdList</title>
        
      <para>The <classname>ThresholdList</classname> performs specialized filter functionality. 
          It provides a view of a source list that is described by a bounded-range. The range
          is bounded by two integer values which represent the upper and lower thresholds as 
          to what values belong to this list. To allow a high level of customization and
          control, the <classname>ThresholdList</classname> uses a single interface called
          <classname>ThresholdEvaluator</classname> to evaluate the contents of the list. This
          is parallel in spirit to the <classname>Comparator</classname> interface, but 
          evaluates an <classname>Object</classname> giving an absolute <code>int</code> value
          as a result rather than a relative one. The <classname>ThresholdList</classname> makes  
          use of a <classname>ThresholdEvaluator</classname> to determine which 
          <classname>Object</classname>s fall within the bounded-range.</para>      
    </section>
      
    <section>
      <title>The ThresholdEvaluator Interface</title>
        
      <para>For the priority property of an <classname>Issue</classname> object, it makes sense
          to use the <code>int</code> value of the priority level as the object evaluation. So 
          let's create a simple <classname>IssueEvaluator</classname> that given an 
          <classname>Issue</classname> returns the priority level.</para>
            
      <informalexample>
        <programlisting linenumbering="numbered">
import ca.odell.glazedlists.ThresholdEvaluator;

public class IssueEvaluator implements ThresholdEvaluator {

    public int evaluate(Object object) {
        Issue issue = (Issue)object;
        String priority = issue.getPriority();
        return Character.getNumericValue(priority.charAt(1));
    }
}          
        </programlisting>
      </informalexample>
        
      <para>Now that we have a concrete <classname>ThresholdEvaluator</classname>, we can create
          a <classname>ThresholdList</classname>. In the <function>constructView()</function>
          method of <classname>IssuesBrowser</classname> we need to create a 
          <classname>ThresholdList</classname> that has the list of issues as data.</para>
            
      <informalexample>
        <programlisting linenumbering="numbered">
    ...
    panel.setLayout(new GridBagLayout());
    IssuesUserFilter issuesUserFiltered = new IssuesUserFilter(issuesEventList);
    ThresholdList issuesPriorityFiltered = new ThresholdList(issuesUserFiltered, new IssueEvaluator());
    SortedList issuesSortedList = new SortedList(issuesPriorityFiltered);          
        </programlisting>
      </informalexample>
        
      <para>Something worth noting is how the lists were layered. The 
          <classname>ThresholdList</classname> enforces a sort order on the list when you use
          it. While this might seem strange to sort the values, this is done to make the
          <classname>ThresholdList</classname> incredibly high-performance. As a result, you
          may have to sort a list after the <classname>ThresholdList</classname> is applied
          to present it in an ordering that makes the most sense for your application. That
          is why the <classname>ThresholdList</classname> decorates the source list before the
          the <classname>SortedList</classname> in applied in our issue browser. Now that we
          have a <classname>ThresholdList</classname>, we need to bind it to a widget to allow
          for user interaction.</para>
    </section>
      
    <section>
      <title>The ThresholdSliderModel</title>
      
      <para>Out of the box, we provide a model for a <classname>JSlider</classname>, called 
          <classname>ThresholdSliderModel</classname>. The <classname>ThresholdSliderModel</classname> 
          is constructed via the <classname>ThresholdSliderModelFactory</classname> and binds
          a <classname>JSlider</classname> to an instance of <classname>ThresholdList</classname>.
          However, since a <classname>JSlider</classname> has only one value that can be set,
          the <classname>ThresholdList</classname> can be bound to the slider in two different
          ways:</para>
      <simplelist>
        <listitem>            
          <para><emphasis>Lower Threshold Slider</emphasis>:
              In this mode, the <classname>ThresholdSliderModel</classname> interacts with the
              <classname>ThresholdList</classname> so that all values in the list are between the 
              current value of the slider and the maximum value defined for the slider. A 
              <classname>ThresholdSliderModel</classname> of this type can be constructed using
              the <function>createLower()</function> method on the 
              <classname>ThresholdSliderModelFactory</classname>.</para>
        </listitem>
        
        <listitem>            
          <para><emphasis>Upper Threshold Slider</emphasis>:
              In this mode, the <classname>ThresholdSliderModel</classname> interacts with the
              <classname>ThresholdList</classname> so that all values in the list are between the
              minimum value of the slider and the current value defined for the slider. A 
              <classname>ThresholdSliderModel</classname> of this type can be constructed using
              the <function>createUpper()</function> method on the 
              <classname>ThresholdSliderModelFactory</classname>.</para>
        </listitem>
      </simplelist>
        
      <para>For our application, we want a range from <constant>1</constant> to the slider value so
          we need to use a slider model in Upper Threshold Slider mode. We will set the slider's
          initial value to <constant>5</constant> so that no issues are filtered out when the 
          application starts.</para>
            
      <informalexample>
        <programlisting linenumbering="numbered">
    ...
    JScrollPane usersListScrollPane = new JScrollPane(issuesUserFiltered.getUserSelect());
    BoundedRangeModel rangeModel = ThresholdRangeModelFactory.createUpper(issuesPriorityFiltered);
    rangeModel.setRangeProperties(5, 0, 1, 5, false);
    JSlider thresholdSlider = new JSlider(rangeModel);
    thresholdSlider.setMajorTickSpacing(1);
    thresholdSlider.setPaintTicks(true);
    thresholdSlider.setPaintLabels(true);
    panel.add(usersListScrollPane, new GridBagConstraints(...));









     TODO: ADD TO DEMO GUI HERE! 









    panel.add(issuesTableScrollPane, new GridBagConstraints(...));
    panel.add(new JLabel("Filter: "), new GridBagConstraints(...));
    panel.add(issuesTextFiltered.getFilterEdit(), new GridBagConstraints(...));          
        </programlisting>
      </informalexample>
    </section>
      
    <section>
      <title>Other Models</title>
                
      <para>So you might be asking yourself "What about models for widgets other than the 
          JSlider?"  Well, the design goals of the <classname>ThresholdList</classname> make
          it a likely pair to not just the <classname>JSlider</classname>, but also the 
          <classname>JComboBox</classname>, the <classname>JTextField</classname> and the 
          <classname>JSpinner</classname>. The reason Glazed Lists supports only one of these
          widget types is that the implementation of a model for the <classname>JSlider</classname>
          component was natural given the <classname>BoundedRangeModel</classname> interface.
          The contract defined in <classname>BoundedRangeModel</classname> provides only two
          possibly ways to connect the component to the <classname>ThresholdList</classname>.
          Connecting the <classname>ThresholdList</classname> to other components is very
          dependant on application specifics, and as such is a task is better left to the
          user.</para>
    </section>
      
    <screenshot>
      <graphic fileref="threshold/screenshot.png">
        <alt>Issues Browser</alt>
      </graphic>
    </screenshot>
      
    <section>
      <title>So What?</title>
       
      <para>We have added a powerful form of filtering to the issues list and introduced one of
          the newest tools in the Glazed Lists toolkit.</para>
    </section>            
  </chapter>    
</book>
